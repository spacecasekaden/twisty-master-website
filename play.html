<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Twisty Puzzle Master</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Exo+2:wght@300;400;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-deep: #0a0a0f;
            --bg-dark: #12121a;
            --bg-panel: rgba(18, 18, 26, 0.85);
            --neon-cyan: #00f5ff;
            --neon-magenta: #ff00aa;
            --neon-yellow: #f0ff00;
            --neon-green: #00ff88;
            --text-primary: #e8e8ff;
            --text-secondary: #8888aa;
            --border-glow: rgba(0, 245, 255, 0.3);
            --shadow-neon: 0 0 20px rgba(0, 245, 255, 0.4);
            --cube-white: #ffffff;
            --cube-yellow: #ffcc00;
            --cube-red: #ff3300;
            --cube-orange: #ff8800;
            --cube-blue: #0066ff;
            --cube-green: #00cc44;
        }

        /* Theme: Neon Cyber (Default) */
        [data-theme="cyber"] {
            --bg-deep: #0a0a0f;
            --bg-dark: #12121a;
            --neon-cyan: #00f5ff;
            --neon-magenta: #ff00aa;
        }

        /* Theme: Sunset Blaze */
        [data-theme="sunset"] {
            --bg-deep: #1a0a0a;
            --bg-dark: #2a1010;
            --bg-panel: rgba(42, 16, 16, 0.9);
            --neon-cyan: #ff6b35;
            --neon-magenta: #f7931e;
            --neon-yellow: #ffcc02;
            --neon-green: #ff4757;
            --text-primary: #fff5e6;
            --border-glow: rgba(255, 107, 53, 0.4);
            --shadow-neon: 0 0 20px rgba(255, 107, 53, 0.5);
        }

        /* Theme: Forest Moss */
        [data-theme="forest"] {
            --bg-deep: #0a1a0a;
            --bg-dark: #102010;
            --bg-panel: rgba(16, 32, 16, 0.9);
            --neon-cyan: #4ade80;
            --neon-magenta: #22c55e;
            --neon-yellow: #a3e635;
            --neon-green: #10b981;
            --text-primary: #e6ffe6;
            --border-glow: rgba(74, 222, 128, 0.4);
            --shadow-neon: 0 0 20px rgba(74, 222, 128, 0.5);
        }

        /* Theme: Galaxy Purple */
        [data-theme="galaxy"] {
            --bg-deep: #0f0a1a;
            --bg-dark: #1a1025;
            --bg-panel: rgba(26, 16, 37, 0.9);
            --neon-cyan: #a855f7;
            --neon-magenta: #ec4899;
            --neon-yellow: #f472b6;
            --neon-green: #c084fc;
            --text-primary: #f5e6ff;
            --border-glow: rgba(168, 85, 247, 0.4);
            --shadow-neon: 0 0 20px rgba(168, 85, 247, 0.5);
        }

        /* Theme: Ocean Deep */
        [data-theme="ocean"] {
            --bg-deep: #0a0f1a;
            --bg-dark: #101828;
            --bg-panel: rgba(16, 24, 40, 0.9);
            --neon-cyan: #06b6d4;
            --neon-magenta: #0ea5e9;
            --neon-yellow: #38bdf8;
            --neon-green: #22d3ee;
            --text-primary: #e6f7ff;
            --border-glow: rgba(6, 182, 212, 0.4);
            --shadow-neon: 0 0 20px rgba(6, 182, 212, 0.5);
        }

        /* Theme: Retro Arcade */
        [data-theme="retro"] {
            --bg-deep: #000000;
            --bg-dark: #111111;
            --bg-panel: rgba(17, 17, 17, 0.95);
            --neon-cyan: #39ff14;
            --neon-magenta: #ff073a;
            --neon-yellow: #fff01f;
            --neon-green: #39ff14;
            --text-primary: #39ff14;
            --text-secondary: #00ff00;
            --border-glow: rgba(57, 255, 20, 0.5);
            --shadow-neon: 0 0 25px rgba(57, 255, 20, 0.6);
        }

        /* Theme: Pastel Dream */
        [data-theme="pastel"] {
            --bg-deep: #fef7ff;
            --bg-dark: #fdf2f8;
            --bg-panel: rgba(253, 242, 248, 0.95);
            --neon-cyan: #f9a8d4;
            --neon-magenta: #c084fc;
            --neon-yellow: #fbbf24;
            --neon-green: #86efac;
            --text-primary: #4a4a6a;
            --text-secondary: #8888aa;
            --border-glow: rgba(249, 168, 212, 0.5);
            --shadow-neon: 0 0 20px rgba(249, 168, 212, 0.4);
            --cube-white: #fef7ff;
            --cube-yellow: #fde047;
            --cube-red: #fb7185;
            --cube-orange: #fdba74;
            --cube-blue: #93c5fd;
            --cube-green: #86efac;
        }

        /* Theme: Monochrome */
        [data-theme="mono"] {
            --bg-deep: #0a0a0a;
            --bg-dark: #151515;
            --bg-panel: rgba(21, 21, 21, 0.95);
            --neon-cyan: #ffffff;
            --neon-magenta: #cccccc;
            --neon-yellow: #ffffff;
            --neon-green: #aaaaaa;
            --text-primary: #ffffff;
            --text-secondary: #888888;
            --border-glow: rgba(255, 255, 255, 0.3);
            --shadow-neon: 0 0 20px rgba(255, 255, 255, 0.3);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Exo 2', sans-serif;
            background: var(--bg-deep);
            color: var(--text-primary);
            overflow: hidden;
            min-height: 100vh;
        }

        #loading-screen {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: var(--bg-deep);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            transition: opacity 0.2s ease, visibility 0.2s ease;
        }

        #loading-screen.hidden { opacity: 0; visibility: hidden; pointer-events: none; }

        .loader { perspective: 200px; }

        .cube-loader {
            width: 60px; height: 60px;
            position: relative;
            transform-style: preserve-3d;
            animation: rotateCube 2s infinite linear;
        }

        .cube-loader .face {
            position: absolute;
            width: 60px; height: 60px;
            border: 2px solid var(--neon-cyan);
            background: rgba(0, 245, 255, 0.1);
            box-shadow: inset 0 0 20px rgba(0, 245, 255, 0.3);
        }

        .cube-loader .front { transform: translateZ(30px); }
        .cube-loader .back { transform: rotateY(180deg) translateZ(30px); }
        .cube-loader .right { transform: rotateY(90deg) translateZ(30px); }
        .cube-loader .left { transform: rotateY(-90deg) translateZ(30px); }
        .cube-loader .top { transform: rotateX(90deg) translateZ(30px); }
        .cube-loader .bottom { transform: rotateX(-90deg) translateZ(30px); }

        @keyframes rotateCube {
            0% { transform: rotateX(0deg) rotateY(0deg); }
            100% { transform: rotateX(360deg) rotateY(360deg); }
        }

        .loading-text {
            margin-top: 30px;
            font-family: 'Orbitron', monospace;
            font-size: 1.2rem;
            color: var(--neon-cyan);
            text-shadow: 0 0 10px var(--neon-cyan);
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }

        #game-container {
            position: relative;
            width: 100vw; height: 100vh;
            background: 
                radial-gradient(ellipse at 20% 80%, rgba(0, 245, 255, 0.08) 0%, transparent 50%),
                radial-gradient(ellipse at 80% 20%, rgba(255, 0, 170, 0.08) 0%, transparent 50%),
                radial-gradient(ellipse at 50% 50%, rgba(18, 18, 26, 1) 0%, var(--bg-deep) 100%);
        }

        #game-container::before {
            content: '';
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background-image: 
                linear-gradient(rgba(0, 245, 255, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 245, 255, 0.03) 1px, transparent 1px);
            background-size: 50px 50px;
            pointer-events: none;
            z-index: 0;
        }

        #puzzle-canvas {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 1;
        }

        #top-bar {
            position: absolute;
            top: 0; left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 8px 20px;
            background: var(--bg-panel);
            backdrop-filter: blur(10px);
            border: 1px solid var(--border-glow);
            border-top: none;
            border-radius: 0 0 15px 15px;
            box-shadow: var(--shadow-neon);
            max-width: calc(100vw - 440px);
            flex-wrap: wrap;
            justify-content: center;
        }

        .logo { display: flex; align-items: center; gap: 6px; }

        .logo-icon {
            font-size: 1.2rem;
            color: var(--neon-cyan);
            text-shadow: 0 0 10px var(--neon-cyan);
        }

        .logo-text {
            font-family: 'Orbitron', monospace;
            font-weight: 900;
            font-size: 0.9rem;
            letter-spacing: 1px;
            background: linear-gradient(90deg, var(--neon-cyan), var(--neon-magenta));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .timer-display, .moves-display, .best-time-display {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .timer-label, .moves-label, .best-label {
            font-size: 0.55rem;
            color: var(--text-secondary);
            letter-spacing: 1px;
        }

        .best-label {
            color: #ffd700;
        }

        #timer, #moves {
            font-family: 'Orbitron', monospace;
            font-size: 1.1rem;
            font-weight: 700;
            color: var(--neon-yellow);
            text-shadow: 0 0 8px var(--neon-yellow);
        }

        #best-time {
            font-family: 'Orbitron', monospace;
            font-size: 0.9rem;
            font-weight: 700;
            color: #ffd700;
            text-shadow: 0 0 8px rgba(255, 215, 0, 0.6);
        }

        #best-time.new-record {
            animation: newRecord 0.5s ease-in-out 3;
        }

        @keyframes newRecord {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.2); color: #00ff88; }
        }

        #puzzle-selector, #controls-panel {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            z-index: 100;
            padding: 25px;
            background: var(--bg-panel);
            backdrop-filter: blur(10px);
            border: 1px solid var(--border-glow);
            box-shadow: var(--shadow-neon);
        }

        #puzzle-selector {
            left: 20px;
            border-radius: 0 20px 20px 0;
            border-left: 3px solid var(--neon-cyan);
            width: 220px;
        }

        #controls-panel {
            right: 20px;
            border-radius: 20px 0 0 20px;
            border-right: 3px solid var(--neon-magenta);
            width: 220px;
        }

        #puzzle-selector h2, #controls-panel h2 {
            font-family: 'Orbitron', monospace;
            font-size: 0.9rem;
            letter-spacing: 3px;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border-glow);
            color: var(--neon-cyan);
        }

        #controls-panel h2 { color: var(--neon-magenta); }

        .category { margin-bottom: 25px; }

        .category h3 {
            font-size: 0.75rem;
            color: var(--text-secondary);
            letter-spacing: 2px;
            margin-bottom: 12px;
        }


        
        .size-input-container {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
            margin-bottom: 10px;
        }
        
        .size-input {
            width: 50px;
            padding: 8px 5px;
            background: var(--bg-dark);
            border: 1px solid var(--border-glow);
            border-radius: 5px;
            color: var(--neon-cyan);
            font-family: 'Orbitron', monospace;
            font-size: 1rem;
            text-align: center;
        }
        
        .size-input:focus {
            outline: none;
            box-shadow: 0 0 10px var(--neon-cyan);
            border-color: var(--neon-cyan);
        }
        
        .size-input:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .size-mult {
            color: var(--neon-cyan);
            font-family: 'Orbitron', monospace;
            font-size: 1rem;
        }
        
        .size-label {
            color: var(--text-secondary);
            font-size: 0.8rem;
            margin-right: 5px;
        }



        #cube-size-label {
            display: block;
            margin-top: 8px;
            font-family: 'Orbitron', monospace;
            font-size: 1rem;
            color: var(--neon-cyan);
            text-shadow: 0 0 8px var(--neon-cyan);
        }

        .puzzle-btn {
            width: 100%;
            padding: 12px 15px;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 12px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid transparent;
            border-radius: 10px;
            color: var(--text-primary);
            font-family: 'Exo 2', sans-serif;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .puzzle-btn:hover {
            background: rgba(0, 245, 255, 0.1);
            border-color: var(--neon-cyan);
            transform: translateX(5px);
        }

        .puzzle-btn.active {
            background: rgba(0, 245, 255, 0.15);
            border-color: var(--neon-cyan);
            box-shadow: 0 0 15px rgba(0, 245, 255, 0.3);
        }

        .btn-icon {
            width: 30px; height: 30px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .cube-icon {
            background: linear-gradient(135deg, #ff6b35 25%, #fff 25%, #fff 50%, #009ddc 50%, #009ddc 75%, #fff 75%);
            background-size: 15px 15px;
            border: 2px solid var(--text-secondary);
        }

        .pyramid-icon {
            width: 0; height: 0;
            border-left: 15px solid transparent;
            border-right: 15px solid transparent;
            border-bottom: 26px solid var(--neon-green);
            background: none;
        }

        .dodeca-icon {
            background: var(--neon-magenta);
            clip-path: polygon(50% 0%, 100% 38%, 82% 100%, 18% 100%, 0% 38%);
        }

        .control-buttons {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 25px;
        }

        .action-btn {
            position: relative;
            padding: 12px 20px;
            background: transparent;
            border: 2px solid var(--neon-magenta);
            border-radius: 8px;
            color: var(--text-primary);
            font-family: 'Orbitron', monospace;
            font-size: 0.8rem;
            letter-spacing: 1px;
            cursor: pointer;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .action-btn .btn-glow {
            position: absolute;
            top: 0; left: -100%;
            width: 100%; height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 0, 170, 0.3), transparent);
            transition: left 0.5s ease;
        }

        .action-btn:hover .btn-glow { left: 100%; }

        .action-btn:hover {
            background: rgba(255, 0, 170, 0.15);
            box-shadow: 0 0 20px rgba(255, 0, 170, 0.4);
            transform: scale(1.02);
        }

        .action-btn .btn-content { position: relative; z-index: 1; }
        .action-btn.large { padding: 18px 40px; font-size: 1rem; }
        
        .action-btn.secondary {
            background: transparent;
            border: 2px solid var(--text-secondary);
        }
        
        .action-btn.secondary:hover {
            border-color: var(--neon-cyan);
            background: rgba(0, 245, 255, 0.1);
        }
        
        .action-btn.secondary .btn-glow {
            background: rgba(0, 245, 255, 0.3);
        }
        
        .modal-buttons {
            display: flex;
            flex-direction: column;
            gap: 12px;
            width: 100%;
        }

        .instructions, .keyboard-shortcuts { margin-bottom: 20px; }

        .instructions h3, .keyboard-shortcuts h3 {
            font-size: 0.75rem;
            color: var(--neon-magenta);
            letter-spacing: 2px;
            margin-bottom: 10px;
        }

        .instructions ul {
            list-style: none;
            font-size: 0.8rem;
            color: var(--text-secondary);
            line-height: 1.8;
        }

        .instructions li strong { color: var(--text-primary); }

        .key-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 10px;
        }

        .key-item { font-size: 0.75rem; color: var(--text-secondary); }

        kbd {
            display: inline-block;
            padding: 3px 8px;
            margin-right: 5px;
            background: var(--bg-dark);
            border: 1px solid var(--border-glow);
            border-radius: 4px;
            font-family: 'Orbitron', monospace;
            font-size: 0.7rem;
            color: var(--neon-cyan);
        }

        .key-hint { font-size: 0.7rem; color: var(--text-secondary); font-style: italic; }

        .speed-control {
            margin: 20px 0;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            border: 1px solid var(--border-glow);
        }

        .speed-control h3 {
            font-family: 'Orbitron', monospace;
            font-size: 0.8rem;
            color: var(--neon-cyan);
            margin-bottom: 12px;
            text-align: center;
            letter-spacing: 2px;
        }

        .speed-slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .speed-label { font-size: 1.2rem; }

        .speed-slider {
            width: 100%;
            -webkit-appearance: none;
            appearance: none;
            height: 8px;
            background: linear-gradient(90deg, var(--neon-green), var(--neon-yellow), var(--neon-magenta));
            border-radius: 4px;
            outline: none;
        }

        .speed-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: var(--neon-cyan);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px var(--neon-cyan);
            transition: transform 0.2s;
        }

        .speed-slider::-webkit-slider-thumb:hover { transform: scale(1.2); }

        .speed-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: var(--neon-cyan);
            border-radius: 50%;
            cursor: pointer;
            border: none;
            box-shadow: 0 0 10px var(--neon-cyan);
        }

        .speed-value {
            text-align: center;
            margin-top: 8px;
            font-family: 'Orbitron', monospace;
            font-size: 0.85rem;
            color: var(--neon-yellow);
        }

        .modal {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        .modal.hidden { opacity: 0; visibility: hidden; pointer-events: none; }

        .modal-content {
            position: relative;
            padding: 50px 60px;
            background: var(--bg-panel);
            border: 2px solid var(--neon-cyan);
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 0 50px rgba(0, 245, 255, 0.5);
            animation: modalPop 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        @keyframes modalPop {
            0% { transform: scale(0.5); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }

        .modal-content h2 {
            font-family: 'Orbitron', monospace;
            font-size: 2.5rem;
            margin-bottom: 30px;
            background: linear-gradient(90deg, var(--neon-cyan), var(--neon-magenta), var(--neon-yellow));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: rainbow 2s linear infinite;
        }

        @keyframes rainbow { 0% { filter: hue-rotate(0deg); } 100% { filter: hue-rotate(360deg); } }

        .stats { display: flex; justify-content: center; gap: 40px; margin-bottom: 30px; }
        .stat { display: flex; flex-direction: column; }
        .stat-label { font-size: 0.8rem; color: var(--text-secondary); letter-spacing: 2px; }

        .stat-value {
            font-family: 'Orbitron', monospace;
            font-size: 2rem;
            font-weight: 700;
            color: var(--neon-yellow);
            text-shadow: 0 0 15px var(--neon-yellow);
        }

        .confetti {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            overflow: hidden;
        }

        /* Achievements Button */
        .achievements-btn {
            display: flex;
            align-items: center;
            gap: 5px;
            padding: 6px 10px;
            background: linear-gradient(135deg, #ffd700, #ff8c00);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .achievements-btn:hover {
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
        }

        .achievements-icon { font-size: 0.85rem; }

        .achievements-text {
            font-family: 'Orbitron', monospace;
            font-size: 0.6rem;
            font-weight: 700;
            color: #1a1a2e;
        }

        .achievement-count {
            background: rgba(0,0,0,0.3);
            padding: 2px 6px;
            border-radius: 8px;
            font-family: 'Orbitron', monospace;
            font-size: 0.5rem;
            font-weight: 700;
            color: white;
        }

        /* Leaderboard Button */
        .leaderboard-btn {
            display: flex;
            align-items: center;
            gap: 5px;
            padding: 6px 10px;
            background: linear-gradient(135deg, #00f5ff, #0088ff);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .leaderboard-btn:hover {
            box-shadow: 0 0 15px rgba(0, 245, 255, 0.5);
        }

        .leaderboard-icon { font-size: 0.85rem; }

        .leaderboard-text {
            font-family: 'Orbitron', monospace;
            font-size: 0.6rem;
            font-weight: 700;
            color: #1a1a2e;
        }

        /* Profile Button */
        .profile-btn {
            display: flex;
            align-items: center;
            gap: 5px;
            padding: 6px 10px;
            background: linear-gradient(135deg, #ff00aa, #ff6600);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .profile-btn:hover {
            box-shadow: 0 0 15px rgba(255, 0, 170, 0.5);
        }

        .profile-icon { font-size: 0.85rem; }

        .profile-text {
            font-family: 'Orbitron', monospace;
            font-size: 0.6rem;
            font-weight: 700;
            color: white;
        }

        .profile-name {
            font-family: 'Orbitron', monospace;
            font-size: 0.55rem;
            font-weight: 400;
            color: rgba(255,255,255,0.9);
            max-width: 60px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* Leaderboard Modal */
        .leaderboard-modal-content {
            width: 90%;
            max-width: 700px;
            max-height: 85vh;
            background: linear-gradient(135deg, var(--bg-dark) 0%, var(--bg-deep) 100%);
            border: 2px solid var(--neon-cyan);
            border-radius: 20px;
            overflow: hidden;
            animation: modalPop 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        .leaderboard-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 25px;
            background: linear-gradient(90deg, #00f5ff, #0088ff);
        }

        .leaderboard-header h2 {
            font-family: 'Orbitron', monospace;
            font-size: 1.3rem;
            color: #1a1a2e;
        }

        .leaderboard-tabs {
            display: flex;
            gap: 5px;
            padding: 15px 20px;
            background: rgba(0,0,0,0.3);
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .leaderboard-tab {
            padding: 8px 16px;
            background: rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            color: var(--text-secondary);
            font-family: 'Orbitron', monospace;
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .leaderboard-tab:hover {
            background: rgba(0, 245, 255, 0.1);
            border-color: var(--neon-cyan);
        }

        .leaderboard-tab.active {
            background: linear-gradient(135deg, var(--neon-cyan), var(--neon-magenta));
            color: #1a1a2e;
            border-color: transparent;
        }

        .leaderboard-list {
            padding: 15px 20px;
            max-height: 50vh;
            overflow-y: auto;
        }

        .leaderboard-entry {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 12px 15px;
            background: rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 10px;
            margin-bottom: 8px;
            transition: all 0.3s ease;
        }

        .leaderboard-entry:hover {
            background: rgba(0, 245, 255, 0.1);
            border-color: var(--neon-cyan);
        }

        .leaderboard-entry.top-3:nth-child(1) {
            border-color: #ffd700;
            background: rgba(255, 215, 0, 0.1);
        }

        .leaderboard-entry.top-3:nth-child(2) {
            border-color: #c0c0c0;
            background: rgba(192, 192, 192, 0.1);
        }

        .leaderboard-entry.top-3:nth-child(3) {
            border-color: #cd7f32;
            background: rgba(205, 127, 50, 0.1);
        }

        .leaderboard-rank {
            font-family: 'Orbitron', monospace;
            font-size: 1.2rem;
            font-weight: 900;
            min-width: 40px;
            text-align: center;
        }

        .leaderboard-rank.gold { color: #ffd700; }
        .leaderboard-rank.silver { color: #c0c0c0; }
        .leaderboard-rank.bronze { color: #cd7f32; }

        .leaderboard-player {
            flex: 1;
        }

        .leaderboard-player-name {
            font-family: 'Orbitron', monospace;
            font-size: 0.9rem;
            font-weight: 700;
            color: var(--text-primary);
        }

        .leaderboard-player-info {
            font-size: 0.7rem;
            color: var(--text-secondary);
            display: flex;
            gap: 10px;
            margin-top: 3px;
        }

        .leaderboard-time {
            font-family: 'Orbitron', monospace;
            font-size: 1.1rem;
            font-weight: 700;
            color: var(--neon-cyan);
        }

        .leaderboard-empty {
            text-align: center;
            padding: 40px;
            color: var(--text-secondary);
        }

        .leaderboard-empty-icon {
            font-size: 3rem;
            margin-bottom: 15px;
            opacity: 0.5;
        }

        /* Sign In Modal */
        .signin-modal-content {
            width: 90%;
            max-width: 450px;
            background: linear-gradient(135deg, var(--bg-dark) 0%, var(--bg-deep) 100%);
            border: 2px solid var(--neon-magenta);
            border-radius: 20px;
            overflow: hidden;
            animation: modalPop 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        .signin-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 25px;
            background: linear-gradient(90deg, #ff00aa, #ff6600);
        }

        .signin-header h2 {
            font-family: 'Orbitron', monospace;
            font-size: 1.3rem;
            color: white;
        }

        .signin-body {
            padding: 25px;
        }

        .signin-field {
            margin-bottom: 20px;
        }

        .signin-label {
            display: block;
            font-family: 'Orbitron', monospace;
            font-size: 0.8rem;
            color: var(--text-primary);
            margin-bottom: 8px;
        }

        .signin-input {
            width: 100%;
            padding: 12px 15px;
            background: rgba(0,0,0,0.4);
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 10px;
            color: var(--text-primary);
            font-family: 'Exo 2', sans-serif;
            font-size: 1rem;
            transition: all 0.3s ease;
            box-sizing: border-box;
        }

        .signin-input:focus {
            outline: none;
            border-color: var(--neon-magenta);
            box-shadow: 0 0 15px rgba(255, 0, 170, 0.3);
        }

        .signin-question {
            margin-bottom: 20px;
        }

        .signin-question-label {
            display: block;
            font-family: 'Orbitron', monospace;
            font-size: 0.8rem;
            color: var(--text-primary);
            margin-bottom: 10px;
        }

        .signin-options {
            display: flex;
            gap: 10px;
        }

        .signin-option {
            flex: 1;
            padding: 12px;
            background: rgba(0,0,0,0.3);
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 10px;
            color: var(--text-secondary);
            font-family: 'Orbitron', monospace;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }

        .signin-option:hover {
            border-color: var(--neon-magenta);
            background: rgba(255, 0, 170, 0.1);
        }

        .signin-option.selected {
            background: linear-gradient(135deg, var(--neon-magenta), var(--neon-cyan));
            color: white;
            border-color: transparent;
        }

        .signin-submit {
            width: 100%;
            padding: 15px;
            background: linear-gradient(135deg, var(--neon-magenta), #ff6600);
            border: none;
            border-radius: 12px;
            color: white;
            font-family: 'Orbitron', monospace;
            font-size: 1rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 10px;
        }

        .signin-submit:hover {
            transform: scale(1.02);
            box-shadow: 0 0 25px rgba(255, 0, 170, 0.5);
        }

        .signin-submit:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .profile-stats {
            background: rgba(0,0,0,0.3);
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .profile-stat-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .profile-stat-row:last-child {
            border-bottom: none;
        }

        .profile-stat-label {
            color: var(--text-secondary);
            font-size: 0.85rem;
        }

        .profile-stat-value {
            color: var(--neon-cyan);
            font-family: 'Orbitron', monospace;
            font-weight: 700;
        }

        .signout-btn {
            width: 100%;
            padding: 12px;
            background: rgba(255, 50, 50, 0.2);
            border: 2px solid #ff3232;
            border-radius: 10px;
            color: #ff3232;
            font-family: 'Orbitron', monospace;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .signout-btn:hover {
            background: rgba(255, 50, 50, 0.3);
        }

        /* Achievement Modal */
        .achievement-modal-content {
            width: 90%;
            max-width: 600px;
            max-height: 80vh;
            background: linear-gradient(135deg, var(--bg-dark) 0%, var(--bg-deep) 100%);
            border: 2px solid #ffd700;
            border-radius: 20px;
            overflow: hidden;
            animation: modalPop 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        .achievement-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 25px;
            background: linear-gradient(90deg, #ffd700, #ff8c00);
        }

        .achievement-header h2 {
            font-family: 'Orbitron', monospace;
            font-size: 1.3rem;
            color: #1a1a2e;
        }

        .achievements-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(170px, 1fr));
            gap: 12px;
            padding: 20px;
            max-height: 55vh;
            overflow-y: auto;
        }

        .achievement-card {
            background: rgba(0, 0, 0, 0.4);
            border: 2px solid #333;
            border-radius: 12px;
            padding: 15px;
            text-align: center;
            transition: all 0.3s ease;
            position: relative;
        }

        .achievement-card.locked {
            opacity: 0.5;
            filter: grayscale(100%);
        }

        .achievement-card.unlocked {
            border-color: #ffd700;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.3);
        }

        .achievement-card.unlocked:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 20px rgba(255, 215, 0, 0.4);
        }

        .achievement-icon {
            font-size: 2rem;
            margin-bottom: 8px;
            display: block;
        }

        .achievement-card.locked .achievement-icon {
            filter: grayscale(100%);
        }

        .achievement-name {
            font-family: 'Orbitron', monospace;
            font-size: 0.75rem;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 5px;
        }

        .achievement-desc {
            font-size: 0.65rem;
            color: var(--text-secondary);
            line-height: 1.3;
        }

        .achievement-card.locked .achievement-name,
        .achievement-card.locked .achievement-desc {
            color: #666;
        }

        /* Achievement Notification Popup */
        .achievement-popup {
            position: fixed;
            top: 100px;
            right: 20px;
            background: linear-gradient(135deg, #1a1a2e, #2a2a4e);
            border: 2px solid #ffd700;
            border-radius: 15px;
            padding: 15px 20px;
            display: flex;
            align-items: center;
            gap: 15px;
            z-index: 10000;
            animation: slideInRight 0.5s ease, slideOutRight 0.5s ease 3.5s forwards;
            box-shadow: 0 5px 30px rgba(255, 215, 0, 0.4);
        }

        @keyframes slideInRight {
            from { transform: translateX(400px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        @keyframes slideOutRight {
            from { transform: translateX(0); opacity: 1; }
            to { transform: translateX(400px); opacity: 0; }
        }

        .popup-icon {
            font-size: 2.5rem;
            animation: popBounce 0.5s ease;
        }

        @keyframes popBounce {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.3); }
        }

        .popup-content {
            display: flex;
            flex-direction: column;
        }

        .popup-title {
            font-family: 'Orbitron', monospace;
            font-size: 0.7rem;
            color: #ffd700;
            letter-spacing: 2px;
        }

        .popup-name {
            font-family: 'Orbitron', monospace;
            font-size: 1rem;
            font-weight: 700;
            color: white;
        }

        .popup-desc {
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        /* Themes Button */
        .themes-btn {
            display: flex;
            align-items: center;
            gap: 5px;
            padding: 6px 10px;
            background: linear-gradient(135deg, var(--neon-magenta), var(--neon-cyan));
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .themes-btn:hover {
            box-shadow: 0 0 15px var(--neon-cyan);
        }

        @keyframes pulse-glow {
            0%, 100% { box-shadow: 0 0 10px rgba(255, 0, 170, 0.3); }
            50% { box-shadow: 0 0 15px rgba(0, 245, 255, 0.4); }
        }

        .themes-btn-icon { font-size: 0.85rem; }

        .themes-btn-text {
            font-family: 'Orbitron', monospace;
            font-size: 0.6rem;
            font-weight: 700;
            color: white;
            text-shadow: 0 0 3px rgba(0,0,0,0.5);
        }

        /* Theme Modal */
        .theme-modal-content {
            width: 90%;
            max-width: 700px;
            max-height: 85vh;
            background: linear-gradient(135deg, var(--bg-dark) 0%, var(--bg-deep) 100%);
            border: 2px solid var(--neon-cyan);
            border-radius: 20px;
            overflow: hidden;
            animation: modalPop 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        .theme-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 25px;
            background: linear-gradient(90deg, var(--neon-magenta), var(--neon-cyan));
        }

        .theme-header h2 {
            font-family: 'Orbitron', monospace;
            font-size: 1.4rem;
            color: white;
            text-shadow: 0 0 10px rgba(0,0,0,0.3);
        }

        .close-theme-btn {
            background: rgba(0,0,0,0.3);
            border: none;
            color: white;
            font-size: 1.5rem;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s;
        }

        .close-theme-btn:hover {
            background: rgba(0,0,0,0.5);
            transform: scale(1.1);
        }

        .themes-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
            padding: 25px;
            max-height: 60vh;
            overflow-y: auto;
        }

        .theme-card {
            position: relative;
            border-radius: 15px;
            overflow: hidden;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 3px solid transparent;
        }

        .theme-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0,0,0,0.4);
        }

        .theme-card.active {
            border-color: var(--neon-yellow);
            box-shadow: 0 0 20px var(--neon-yellow);
        }

        .theme-card.locked {
            opacity: 0.7;
        }

        .theme-card.locked::after {
            content: 'ðŸ”’';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 2rem;
            z-index: 10;
            filter: drop-shadow(0 0 10px rgba(0,0,0,0.8));
        }

        .theme-preview {
            height: 100px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .preview-cube {
            width: 50px;
            height: 50px;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 2px;
            transform: perspective(100px) rotateX(10deg) rotateY(-20deg);
        }

        .preview-cube span {
            border-radius: 2px;
        }

        .theme-info {
            padding: 12px 15px;
            background: rgba(0,0,0,0.4);
        }

        .theme-name {
            font-family: 'Orbitron', monospace;
            font-size: 0.9rem;
            font-weight: 700;
            margin-bottom: 4px;
        }

        .theme-status {
            font-size: 0.75rem;
            opacity: 0.7;
        }

        .unlock-hint {
            display: flex;
            align-items: center;
            gap: 5px;
            color: var(--neon-yellow);
            font-size: 0.75rem;
            margin-top: 5px;
        }


        .retro-theme-badge {
            position: absolute;
            top: 5px;
            right: 5px;
            background: linear-gradient(135deg, #ff6600, #8b4513);
            color: white;
            font-size: 0.5rem;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'Orbitron', monospace;
        }


       
        /* Impossible Mode Styles */
        .impossible-toggle {
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid var(--border-glow);
        }

        .impossible-btn {
            width: 100%;
            padding: 12px 15px;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            border: 2px solid #444;
            border-radius: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .impossible-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
            transition: left 0.5s;
        }

        .impossible-btn:hover::before {
            left: 100%;
        }

        .impossible-btn:hover {
            border-color: #ff00aa;
            box-shadow: 0 0 20px rgba(255, 0, 170, 0.3);
        }

        .impossible-btn.active {
            background: linear-gradient(135deg, #ff0080, #ff8c00, #00f5ff, #ff0080);
            background-size: 300% 300%;
            animation: impossibleGradient 3s ease infinite;
            border-color: transparent;
            box-shadow: 0 0 25px rgba(255, 0, 128, 0.5);
        }

        @keyframes impossibleGradient {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .impossible-icon {
            font-size: 1.3rem;
            animation: rainbowPulse 2s ease-in-out infinite;
        }

        @keyframes rainbowPulse {
            0%, 100% { filter: hue-rotate(0deg); }
            50% { filter: hue-rotate(180deg); }
        }

        .impossible-text {
            font-family: 'Orbitron', monospace;
            font-size: 0.75rem;
            font-weight: 700;
            color: var(--text-primary);
            letter-spacing: 1px;
        }

        .impossible-btn.active .impossible-text {
            color: white;
            text-shadow: 0 0 10px rgba(255,255,255,0.5);
        }

        .impossible-hint {
            font-size: 0.65rem;
            color: var(--text-secondary);
            text-align: center;
            margin-top: 8px;
            font-style: italic;
        }

        /* Secret Code Input */
        .secret-code-section {
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid rgba(255,255,255,0.1);
        }

        .secret-input {
            width: 100%;
            padding: 10px 15px;
            background: rgba(0, 0, 0, 0.4);
            border: 1px dashed #444;
            border-radius: 8px;
            color: var(--text-secondary);
            font-family: 'Orbitron', monospace;
            font-size: 0.7rem;
            text-align: center;
            letter-spacing: 2px;
            transition: all 0.3s ease;
        }

        .secret-input:focus {
            outline: none;
            border-color: var(--neon-cyan);
            box-shadow: 0 0 10px rgba(0, 245, 255, 0.3);
            color: var(--neon-cyan);
        }

        .secret-input::placeholder {
            color: #444;
            letter-spacing: 1px;
        }

        .secret-input.success {
            border-color: #ffe600;
            color: #ffe600;
            animation: codeSuccess 0.5s ease;
        }

        @keyframes codeSuccess {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

     

        /* Race AI Button */
        .race-btn {
            background: linear-gradient(135deg, #ff6600, #ff3300) !important;
            border-color: #ff4400 !important;
        }

        .race-btn:hover {
            box-shadow: 0 0 25px rgba(255, 102, 0, 0.6) !important;
        }

        /* Race Modal */
        .race-modal-content {
            width: 95%;
            max-width: 1200px;
            max-height: 90vh;
            background: linear-gradient(135deg, #0a0a15 0%, #151525 100%);
            border: 3px solid #ff6600;
            border-radius: 20px;
            overflow: visible;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        .race-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 25px;
            background: linear-gradient(90deg, #ff6600, #ff3300);
            border-radius: 17px 17px 0 0;
            position: relative;
            z-index: 100;
            flex-shrink: 0;
        }

        .race-header h2 {
            font-family: 'Orbitron', monospace;
            font-size: 1.3rem;
            color: white;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .race-close-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 2px solid white;
            background: #ff0000;
            color: white;
            font-size: 1.4rem;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            z-index: 10000;
            pointer-events: auto;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            flex-shrink: 0;
            line-height: 1;
            padding: 0;
        }

        .race-close-btn:hover {
            background: #cc0000;
            border-color: white;
            transform: scale(1.1);
        }

        .race-close-btn:active {
            transform: scale(0.95);
            background: #aa0000;
        }

        .race-body {
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            overflow-y: auto;
            max-height: calc(90vh - 70px);
        }

        .race-countdown {
            text-align: center;
            padding: 30px;
        }

        .countdown-number {
            font-family: 'Orbitron', monospace;
            font-size: 8rem;
            font-weight: 900;
            color: #ff6600;
            text-shadow: 0 0 50px rgba(255, 102, 0, 0.8);
            animation: countdownPulse 1s ease-in-out infinite;
        }

        .countdown-text {
            font-family: 'Orbitron', monospace;
            font-size: 1.5rem;
            color: #888;
            margin-top: 10px;
        }

        @keyframes countdownPulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.1); opacity: 0.8; }
        }

        .countdown-go {
            color: #00ff00 !important;
            text-shadow: 0 0 50px rgba(0, 255, 0, 0.8) !important;
        }

        .race-arena {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            gap: 20px;
            align-items: start;
        }

        .race-player {
            background: rgba(20, 20, 35, 0.9);
            border-radius: 15px;
            padding: 20px;
            border: 2px solid #333;
        }

        .race-player.you {
            border-color: var(--neon-cyan);
            box-shadow: 0 0 20px rgba(0, 245, 255, 0.2);
        }

        .race-player.ai {
            border-color: #ff6600;
            box-shadow: 0 0 20px rgba(255, 102, 0, 0.2);
        }

        .race-player-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 15px;
        }

        .race-player-name {
            font-family: 'Orbitron', monospace;
            font-size: 1.2rem;
            font-weight: 700;
        }

        .race-player.you .race-player-name {
            color: var(--neon-cyan);
        }

        .race-player.ai .race-player-name {
            color: #ff6600;
        }

        .race-player-status {
            font-size: 0.8rem;
            color: #888;
        }

        .race-player-status.solving {
            color: #ffcc00;
        }

        .race-player-status.finished {
            color: #00ff00;
        }

        .race-cube-container {
            width: 100%;
            min-width: 300px;
            height: 280px;
            min-height: 280px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            position: relative;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .race-cube-container canvas {
            display: block;
        }

        .race-stats {
            display: flex;
            justify-content: space-around;
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #333;
        }

        .race-stat {
            text-align: center;
        }

        .race-stat-value {
            font-family: 'Orbitron', monospace;
            font-size: 1.5rem;
            color: #fff;
        }

        .race-stat-label {
            font-size: 0.7rem;
            color: #888;
            text-transform: uppercase;
        }

        .race-vs {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .race-vs-text {
            font-family: 'Orbitron', monospace;
            font-size: 2rem;
            font-weight: 900;
            color: #ff6600;
            text-shadow: 0 0 20px rgba(255, 102, 0, 0.5);
        }

        .race-result {
            text-align: center;
            padding: 30px;
            display: none;
        }

        .race-result.show {
            display: block;
        }

        .race-result-title {
            font-family: 'Orbitron', monospace;
            font-size: 3rem;
            font-weight: 900;
            margin-bottom: 15px;
        }

        .race-result-title.win {
            color: #00ff00;
            text-shadow: 0 0 30px rgba(0, 255, 0, 0.6);
        }

        .race-result-title.lose {
            color: #ff4444;
            text-shadow: 0 0 30px rgba(255, 68, 68, 0.6);
        }

        .race-result-details {
            font-size: 1rem;
            color: #aaa;
            margin-bottom: 20px;
        }

        .race-again-btn {
            padding: 15px 40px;
            background: linear-gradient(135deg, #ff6600, #ff3300);
            border: none;
            border-radius: 10px;
            color: white;
            font-family: 'Orbitron', monospace;
            font-size: 1rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .race-again-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 25px rgba(255, 102, 0, 0.5);
        }

        .ai-thinking {
            display: flex;
            align-items: center;
            gap: 10px;
            justify-content: center;
            margin-top: 10px;
        }

        .ai-thinking-dots {
            display: flex;
            gap: 5px;
        }

        .ai-thinking-dot {
            width: 8px;
            height: 8px;
            background: #ff6600;
            border-radius: 50%;
            animation: thinkingBounce 1.4s ease-in-out infinite;
        }

        .ai-thinking-dot:nth-child(2) { animation-delay: 0.2s; }
        .ai-thinking-dot:nth-child(3) { animation-delay: 0.4s; }

        @keyframes thinkingBounce {
            0%, 80%, 100% { transform: scale(0.6); opacity: 0.5; }
            40% { transform: scale(1); opacity: 1; }
        }

        .ai-difficulty {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-bottom: 20px;
        }

        .ai-diff-btn {
            padding: 10px 20px;
            background: rgba(40, 40, 50, 0.9);
            border: 2px solid #444;
            border-radius: 8px;
            color: #aaa;
            font-family: 'Orbitron', monospace;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .ai-diff-btn:hover {
            border-color: #ff6600;
            color: #ff6600;
        }

        .ai-diff-btn.active {
            background: rgba(255, 102, 0, 0.2);
            border-color: #ff6600;
            color: #ff6600;
        }

        @media (max-width: 900px) {
            .race-arena {
                grid-template-columns: 1fr;
            }
            .race-vs {
                padding: 10px;
            }
            .race-vs-text {
                font-size: 1.5rem;
            }
        }

        .channel-embed {
            padding: 20px;
        }

        .channel-header {
            display: flex;
            align-items: center;
            gap: 20px;
            margin-bottom: 25px;
            padding: 20px;
            background: rgba(255, 0, 0, 0.1);
            border-radius: 15px;
            border: 1px solid rgba(255, 0, 0, 0.3);
        }

        .channel-logo {
            width: 80px;
            height: 80px;
            background: linear-gradient(135deg, #ff0000, #cc0000);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Orbitron', monospace;
            font-size: 1.8rem;
            font-weight: 900;
            color: white;
            text-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }

        .channel-info-box h3 {
            font-family: 'Orbitron', monospace;
            font-size: 1.5rem;
            color: #fff;
            margin-bottom: 5px;
        }

        .channel-info-box p {
            color: #888;
            font-size: 0.85rem;
            margin-bottom: 5px;
        }

        .channel-desc {
            color: #aaa !important;
            font-size: 0.8rem !important;
        }

        .channel-links {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 10px;
            margin-bottom: 25px;
        }

        .channel-link {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 15px 20px;
            background: rgba(40, 40, 40, 0.9);
            border: 1px solid #444;
            border-radius: 10px;
            color: #fff;
            text-decoration: none;
            font-family: 'Orbitron', monospace;
            font-size: 0.8rem;
            transition: all 0.3s ease;
        }

        .channel-link:hover {
            background: rgba(255, 0, 0, 0.2);
            border-color: #ff0000;
            transform: translateY(-2px);
        }

        .channel-link.main {
            background: #ff0000;
            border-color: #ff0000;
        }

        .channel-link.main:hover {
            background: #cc0000;
            box-shadow: 0 5px 20px rgba(255, 0, 0, 0.4);
        }

        .playlist-section h4 {
            font-family: 'Orbitron', monospace;
            color: #ff4444;
            margin-bottom: 15px;
            font-size: 1rem;
        }

        .playlist-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
        }

        .playlist-card {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            padding: 20px 15px;
            background: rgba(30, 30, 30, 0.9);
            border: 1px solid #333;
            border-radius: 12px;
            color: #fff;
            text-decoration: none;
            transition: all 0.3s ease;
        }

        .playlist-card:hover {
            background: rgba(255, 0, 0, 0.15);
            border-color: #ff0000;
            transform: translateY(-3px);
        }

        .playlist-icon {
            font-size: 2rem;
        }

        .playlist-name {
            font-family: 'Orbitron', monospace;
            font-size: 0.75rem;
            color: #ccc;
        }

        .video-frame-container {
            width: 100%;
            padding: 20px;
        }

        .full-video-frame {
            width: 100%;
            height: 400px;
            border: none;
            border-radius: 12px;
        }

        .video-note {
            text-align: center;
            padding: 15px;
        }

        .video-note a {
            color: #ff4444;
            text-decoration: none;
            font-family: 'Orbitron', monospace;
            font-size: 0.85rem;
        }

        .video-note a:hover {
            color: #ff6666;
            text-decoration: underline;
        }

        /* Ban Screen */
        .ban-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #0a0a0a;
            z-index: 99999;
            display: flex;
            align-items: center;
            justify-content: center;
            animation: banFlicker 0.1s ease-in-out;
        }

        .ban-screen.hidden {
            display: none;
        }

        @keyframes banFlicker {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.8; }
        }

        @keyframes foreverShake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px) rotate(-0.5deg); }
            75% { transform: translateX(5px) rotate(0.5deg); }
        }

        @keyframes foreverFlash {
            0% { background: #ff0000; }
            100% { background: transparent; }
        }

        /* Secret Skull Button */
        .secret-skull {
            position: fixed;
            top: 10px;
            right: 10px;
            font-size: 24px;
            opacity: 0.4;
            cursor: pointer;
            user-select: none;
            z-index: 999999;
            transition: all 0.3s;
            padding: 10px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.3);
        }

        .secret-skull:hover {
            opacity: 0.8;
            transform: scale(1.2);
            background: rgba(100, 0, 0, 0.5);
        }

        .secret-skull:active {
            transform: scale(0.9);
        }

        /* Sue Modal */
        .sue-modal-content {
            width: 90%;
            max-width: 600px;
            max-height: 85vh;
            background: linear-gradient(135deg, #1a0a0a 0%, #0a0a1a 100%);
            border: 3px solid #8b0000;
            border-radius: 15px;
            overflow: hidden;
        }

        .sue-header {
            padding: 15px 20px;
            background: linear-gradient(90deg, #8b0000, #4a0000);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .sue-header h2 {
            font-family: 'Orbitron', monospace;
            color: #ff4444;
            font-size: 1.2rem;
        }

        .sue-body {
            padding: 20px;
            overflow-y: auto;
            max-height: calc(85vh - 60px);
        }

        .sue-section {
            background: rgba(20, 20, 30, 0.9);
            border: 1px solid #333;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
        }

        .sue-section h3 {
            font-family: 'Orbitron', monospace;
            color: #ff6666;
            font-size: 0.9rem;
            margin-bottom: 10px;
            border-bottom: 1px solid #333;
            padding-bottom: 5px;
        }

        .sue-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid #222;
        }

        .sue-row:last-child {
            border-bottom: none;
        }

        .sue-label {
            color: #aaa;
            font-size: 0.85rem;
        }

        .sue-btn {
            padding: 8px 15px;
            background: linear-gradient(135deg, #8b0000, #4a0000);
            border: 1px solid #ff4444;
            border-radius: 5px;
            color: #ff4444;
            font-family: 'Orbitron', monospace;
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .sue-btn:hover {
            background: #ff4444;
            color: #000;
        }

        .sue-btn.green {
            background: linear-gradient(135deg, #004400, #002200);
            border-color: #00ff00;
            color: #00ff00;
        }

        .sue-btn.green:hover {
            background: #00ff00;
            color: #000;
        }

        .sue-input {
            padding: 6px 10px;
            background: #111;
            border: 1px solid #444;
            border-radius: 5px;
            color: #fff;
            font-family: 'Orbitron', monospace;
            font-size: 0.8rem;
            width: 80px;
        }

        .sue-warning {
            text-align: center;
            padding: 15px;
            background: rgba(139, 0, 0, 0.2);
            border: 1px solid #8b0000;
            border-radius: 10px;
            margin-top: 15px;
        }

        .sue-warning p {
            color: #ff6666;
            font-size: 0.8rem;
            margin: 5px 0;
        }

        .ban-content {
            text-align: center;
            padding: 40px;
            max-width: 500px;
        }

        .ban-icon {
            font-size: 80px;
            animation: banPulse 1s ease-in-out infinite;
            margin-bottom: 20px;
        }

        @keyframes banPulse {
            0%, 100% { transform: scale(1); filter: drop-shadow(0 0 20px #ff0000); }
            50% { transform: scale(1.1); filter: drop-shadow(0 0 40px #ff0000); }
        }

        .ban-title {
            font-family: 'Orbitron', monospace;
            font-size: 2.5rem;
            color: #ff0000;
            text-shadow: 0 0 30px #ff0000, 0 0 60px #ff0000;
            margin-bottom: 30px;
            animation: banShake 0.5s ease-in-out infinite;
        }

        @keyframes banShake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }

        .ban-reason, .ban-id, .ban-duration {
            margin: 15px 0;
            padding: 10px 20px;
            background: rgba(255, 0, 0, 0.1);
            border: 1px solid #ff0000;
            border-radius: 8px;
        }

        .ban-label {
            font-family: 'Orbitron', monospace;
            font-size: 0.8rem;
            color: #888;
            margin-right: 10px;
        }

        .ban-text {
            font-family: 'Orbitron', monospace;
            color: #ff6666;
        }

        .ban-code {
            font-family: 'Courier New', monospace;
            color: #ff4444;
            letter-spacing: 2px;
        }

        .ban-forever {
            font-family: 'Orbitron', monospace;
            font-size: 1.2rem;
            font-weight: 900;
            color: #ff0000;
            text-shadow: 0 0 10px #ff0000;
            animation: foreverPulse 0.5s ease-in-out infinite;
        }

        @keyframes foreverPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .ban-message {
            margin: 25px 0;
            color: #888;
            font-size: 0.9rem;
            line-height: 1.6;
        }

        .ban-email {
            color: #666;
            text-decoration: underline;
            font-style: italic;
        }

        .ban-countdown {
            margin-top: 30px;
            font-family: 'Orbitron', monospace;
            font-size: 1.5rem;
            color: #ff4444;
        }

        #ban-timer {
            font-weight: 900;
            color: #ff0000;
            text-shadow: 0 0 15px #ff0000;
        }

        .ban-hint {
            font-size: 0.7rem;
            color: #444;
            font-style: italic;
        }

        .ban-appeal {
            margin-top: 25px;
        }

        .ban-appeal-input {
            width: 250px;
            padding: 12px 20px;
            background: rgba(255, 0, 0, 0.1);
            border: 2px solid #ff0000;
            border-radius: 8px;
            color: #ff6666;
            font-family: 'Orbitron', monospace;
            font-size: 0.9rem;
            text-align: center;
            transition: all 0.3s ease;
        }

        .ban-appeal-input:focus {
            outline: none;
            border-color: #ff4444;
            box-shadow: 0 0 20px rgba(255, 0, 0, 0.4);
        }

        .ban-appeal-input::placeholder {
            color: #663333;
        }

        .ban-appeal-input.success {
            border-color: #00ff88;
            color: #00ff88;
            background: rgba(0, 255, 136, 0.1);
        }

        .unban-btn {
            margin-top: 30px;
            padding: 15px 40px;
            background: linear-gradient(135deg, #00ff88, #00ccff);
            border: none;
            border-radius: 12px;
            font-family: 'Orbitron', monospace;
            font-size: 1rem;
            font-weight: 700;
            color: #1a1a2e;
            cursor: pointer;
            transition: all 0.3s ease;
            animation: unbounce 0.5s ease-in-out infinite;
        }

        .unban-btn.hidden {
            display: none;
        }

        .unban-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 0 30px rgba(0, 255, 136, 0.6);
        }

        @keyframes unbounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-5px); }
        }

        .ban-glitch {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                rgba(255, 0, 0, 0.03) 2px,
                rgba(255, 0, 0, 0.03) 4px
            );
            pointer-events: none;
            animation: scanlines 8s linear infinite;
        }

        @keyframes scanlines {
            from { background-position: 0 0; }
            to { background-position: 0 100%; }
        }

    

        @media (max-width: 900px) {
            #puzzle-selector { left: 10px; width: 160px; padding: 15px; }
            #controls-panel { right: 10px; width: 160px; padding: 15px; }
            #top-bar { gap: 10px; padding: 6px 15px; }
            .themes-btn-text { display: none; }
        }

        @media (max-width: 600px) {
            #puzzle-selector, #controls-panel {
                position: fixed;
                top: auto; bottom: 0;
                left: 0; right: 0;
                transform: none;
                width: 100%;
                border-radius: 20px 20px 0 0;
                border: none;
                border-top: 2px solid var(--neon-cyan);
                max-height: 40vh;
                overflow-y: auto;
            }
            #controls-panel { display: none; }
            .themes-grid { grid-template-columns: repeat(2, 1fr); }
        }
    </style>
</head>
<body>


    <div id="game-container">
        <canvas id="puzzle-canvas"></canvas>
        
        <header id="top-bar">
            <div class="logo">
                <span class="logo-icon">â—ˆ</span>
                <span class="logo-text">TWISTY MASTER</span>
            </div>
            <div class="timer-display">
                <span class="timer-label">TIME</span>
                <span id="timer">00:00.00</span>
            </div>
            <div class="moves-display">
                <span class="moves-label">MOVES</span>
                <span id="moves">0</span>
            </div>
            <div class="best-time-display">
                <span class="best-label">ðŸ† BEST</span>
                <span id="best-time">--:--.--</span>
            </div>
            <button class="achievements-btn" id="achievements-btn">
                <span class="achievements-icon">ðŸ…</span>
                <span class="achievements-text">ACHIEVEMENTS</span>
                <span class="achievement-count" id="achievement-count">0/22</span>
            </button>
            <button class="leaderboard-btn" id="leaderboard-btn">
                <span class="leaderboard-icon">ðŸ†</span>
                <span class="leaderboard-text">LEADERBOARD</span>
            </button>
            <button class="profile-btn" id="profile-btn">
                <span class="profile-icon">ðŸ‘¤</span>
                <span class="profile-text" id="profile-btn-text">SIGN IN</span>
            </button>

        </header>

        <aside id="puzzle-selector">
            <h2>CUBE SIZE</h2>
            <div class="puzzle-categories">
                <div class="category">
                    <div class="size-input-container">
                        <input type="number" id="cube-size-input" min="1" max="30" value="3" class="size-input">
                        <span class="size-mult">Ã—</span>
                        <input type="number" id="cube-size-input2" min="1" max="30" value="3" class="size-input" disabled>
                        <span class="size-mult">Ã—</span>
                        <input type="number" id="cube-size-input3" min="1" max="30" value="3" class="size-input" disabled>
                    </div>
                    <button class="puzzle-btn active" id="apply-size-btn">Apply Size</button>
                </div>
            </div>
            
            <div class="impossible-toggle">
                <button id="impossible-btn" class="impossible-btn">
                    <span class="impossible-icon">ðŸŒˆ</span>
                    <span class="impossible-text">IMPOSSIBLE MODE</span>
                </button>
                <p class="impossible-hint">Colors change with viewing angle!</p>
            </div>
       

 
        </aside>

        <aside id="controls-panel">
            <h2>CONTROLS</h2>
            <div class="control-buttons">
                <button id="scramble-btn" class="action-btn">
                    <span class="btn-glow"></span>
                    <span class="btn-content">ðŸ”€ SCRAMBLE</span>
                </button>
                <button id="reset-btn" class="action-btn">
                    <span class="btn-glow"></span>
                    <span class="btn-content">â†º RESET</span>
                </button>
                <button id="solve-btn" class="action-btn">
                    <span class="btn-glow"></span>
                    <span class="btn-content">âœ“ AUTO SOLVE</span>
                </button>
                <button id="race-btn" class="action-btn race-btn">
                    <span class="btn-glow"></span>
                    <span class="btn-content">ðŸ RACE AI</span>
                </button>
            </div>
            
            <div class="speed-control">
                <h3>SOLVE SPEED</h3>
                <div class="speed-slider-container">
                    <span class="speed-label">ðŸ¢</span>
                    <input type="range" id="solve-speed" min="50" max="500" value="200" class="speed-slider">
                    <span class="speed-label">ðŸ‡</span>
                </div>
                <div class="speed-value"><span id="speed-display">200</span>ms</div>
            </div>
            
            <div class="instructions">
                <h3>HOW TO PLAY</h3>
                <ul>
                    <li><strong>Rotate View:</strong> Click + Drag</li>
                    <li><strong>Turn Face:</strong> Click face + Drag</li>
                    <li><strong>Zoom:</strong> Scroll wheel</li>
                </ul>
            </div>

            <div class="keyboard-shortcuts">
                <h3>KEYBOARD</h3>
                <div class="key-grid">
                    <div class="key-item"><kbd>U</kbd> Up</div>
                    <div class="key-item"><kbd>D</kbd> Down</div>
                    <div class="key-item"><kbd>L</kbd> Left</div>
                    <div class="key-item"><kbd>R</kbd> Right</div>
                    <div class="key-item"><kbd>F</kbd> Front</div>
                    <div class="key-item"><kbd>B</kbd> Back</div>
                </div>
                <p class="key-hint">Hold SHIFT for counter-clockwise</p>
            </div>
        </aside>

        <div id="solved-modal" class="modal hidden">
            <div class="modal-content">
                <div class="confetti"></div>
                <h2>ðŸŽ‰ SOLVED! ðŸŽ‰</h2>
                <div class="stats">
                    <div class="stat">
                        <span class="stat-label">Time</span>
                        <span id="final-time" class="stat-value">00:00.00</span>
                    </div>
                    <div class="stat">
                        <span class="stat-label">Moves</span>
                        <span id="final-moves" class="stat-value">0</span>
                    </div>
                </div>
                <div class="modal-buttons">
                    <button id="play-again-btn" class="action-btn large">
                        <span class="btn-glow"></span>
                        <span class="btn-content">ðŸ”€ PLAY AGAIN</span>
                    </button>
                    <button id="close-solved-btn" class="action-btn large secondary">
                        <span class="btn-glow"></span>
                        <span class="btn-content">âœ“ CLOSE</span>
                    </button>
                </div>
            </div>
        </div>

        <!-- Themes Modal -->
        <div id="themes-modal" class="modal hidden">
            <div class="theme-modal-content">
                <div class="theme-header">
                    <h2>ðŸŽ¨ CHOOSE YOUR STYLE</h2>
                    <button class="close-theme-btn" id="close-themes-btn">Ã—</button>
                </div>
                <div class="themes-grid" id="themes-grid">
                    <!-- Themes will be populated by JavaScript -->
                </div>
            </div>
        </div>

        <!-- Achievements Modal -->
        <div id="achievements-modal" class="modal hidden">
            <div class="achievement-modal-content">
                <div class="achievement-header">
                    <h2>ðŸ… ACHIEVEMENTS</h2>
                    <button class="close-theme-btn" id="close-achievements-btn">Ã—</button>
                </div>
                <div class="achievements-grid" id="achievements-grid">
                    <!-- Achievements will be populated by JavaScript -->
                </div>
            </div>
        </div>

        <!-- Achievement Popup Container -->
        <div id="achievement-popup-container"></div>

        <!-- Sign In Modal -->
        <div id="signin-modal" class="modal hidden">
            <div class="signin-modal-content">
                <div class="signin-header">
                    <h2>ðŸ‘¤ PLAYER PROFILE</h2>
                    <button class="close-theme-btn" id="close-signin-btn">Ã—</button>
                </div>
                <div class="signin-body" id="signin-body">
                    <!-- Sign in form (shown when not signed in) -->
                    <div id="signin-form">
                        <div class="signin-field">
                            <label class="signin-label">What's your name?</label>
                            <input type="text" id="player-name-input" class="signin-input" placeholder="Enter your name..." maxlength="20">
                        </div>
                        
                        <div class="signin-question">
                            <label class="signin-question-label">Have you ever solved a Rubik's cube in real life?</label>
                            <div class="signin-options">
                                <button class="signin-option" data-question="solved" data-value="yes">âœ… Yes!</button>
                                <button class="signin-option" data-question="solved" data-value="no">âŒ No</button>
                                <button class="signin-option" data-question="solved" data-value="learning">ðŸ“š Learning</button>
                            </div>
                        </div>
                        
                        <div class="signin-question">
                            <label class="signin-question-label">Have you ever cheated in a puzzle game?</label>
                            <div class="signin-options">
                                <button class="signin-option" data-question="cheated" data-value="never">ðŸ˜‡ Never!</button>
                                <button class="signin-option" data-question="cheated" data-value="maybe">ðŸ˜… Maybe...</button>
                                <button class="signin-option" data-question="cheated" data-value="yes">ðŸ˜ˆ Of course!</button>
                            </div>
                        </div>
                        
                        <button class="signin-submit" id="signin-submit-btn" disabled>START PLAYING</button>
                    </div>
                    
                    <!-- Profile view (shown when signed in) -->
                    <div id="profile-view" class="hidden">
                        <div class="signin-field">
                            <label class="signin-label">Player Name</label>
                            <div style="font-family: 'Orbitron', monospace; font-size: 1.5rem; color: var(--neon-cyan);" id="profile-display-name"></div>
                        </div>
                        
                        <div class="profile-stats">
                            <div class="profile-stat-row">
                                <span class="profile-stat-label">Fastest Solve (3Ã—3)</span>
                                <span class="profile-stat-value" id="profile-best-time">--:--</span>
                            </div>
                            <div class="profile-stat-row">
                                <span class="profile-stat-label">Total Solves</span>
                                <span class="profile-stat-value" id="profile-total-solves">0</span>
                            </div>
                            <div class="profile-stat-row">
                                <span class="profile-stat-label">Solved IRL?</span>
                                <span class="profile-stat-value" id="profile-solved-irl">--</span>
                            </div>
                            <div class="profile-stat-row">
                                <span class="profile-stat-label">Ever Cheated?</span>
                                <span class="profile-stat-value" id="profile-cheated">--</span>
                            </div>
                        </div>
                        
                        <button class="signout-btn" id="signout-btn">ðŸšª SIGN OUT</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Leaderboard Modal -->
        <div id="leaderboard-modal" class="modal hidden">
            <div class="leaderboard-modal-content">
                <div class="leaderboard-header">
                    <h2>ðŸ† FASTEST SOLVES</h2>
                    <button class="close-theme-btn" id="close-leaderboard-btn">Ã—</button>
                </div>
                <div class="leaderboard-tabs">
                    <button class="leaderboard-tab active" data-size="3">3Ã—3</button>
                    <button class="leaderboard-tab" data-size="2">2Ã—2</button>
                    <button class="leaderboard-tab" data-size="4">4Ã—4</button>
                    <button class="leaderboard-tab" data-size="5">5Ã—5</button>
                    <button class="leaderboard-tab" data-size="all">All Sizes</button>
                </div>
                <div class="leaderboard-list" id="leaderboard-list">
                    <!-- Leaderboard entries will be populated by JavaScript -->
                </div>
            </div>
        </div>





        <!-- Race AI Modal -->
        <div id="race-modal" class="modal hidden">
            <div class="race-modal-content">
                <div class="race-header">
                    <h2>ðŸ RACE vs AI</h2>
                    <button class="race-close-btn" id="close-race-btn" type="button" onclick="window.closeRaceModal && window.closeRaceModal()">âœ•</button>
                </div>
                <div class="race-body">
                    <div class="ai-difficulty">
                        <button class="ai-diff-btn" data-diff="easy">ðŸŸ¢ Easy</button>
                        <button class="ai-diff-btn active" data-diff="medium">ðŸŸ¡ Medium</button>
                        <button class="ai-diff-btn" data-diff="hard">ðŸ”´ Hard</button>
                        <button class="ai-diff-btn" data-diff="insane">ðŸ’€ Insane</button>
                    </div>
                    
                    <div class="race-countdown" id="race-countdown">
                        <div class="countdown-number" id="countdown-display">5</div>
                        <div class="countdown-text">Get Ready!</div>
                    </div>
                    
                    <div class="race-arena" id="race-arena" style="display: none;">
                        <div class="race-player you">
                            <div class="race-player-header">
                                <span class="race-player-name">ðŸ‘¤ YOU</span>
                                <span class="race-player-status" id="player-status">Ready</span>
                            </div>
                            <div class="race-cube-container" id="player-cube-container">
                                <!-- Player's cube rendered here -->
                            </div>
                            <div class="race-stats">
                                <div class="race-stat">
                                    <div class="race-stat-value" id="player-time">0.00</div>
                                    <div class="race-stat-label">Time</div>
                                </div>
                                <div class="race-stat">
                                    <div class="race-stat-value" id="player-moves">0</div>
                                    <div class="race-stat-label">Moves</div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="race-vs">
                            <div class="race-vs-text">VS</div>
                        </div>
                        
                        <div class="race-player ai">
                            <div class="race-player-header">
                                <span class="race-player-name">ðŸ¤– AI</span>
                                <span class="race-player-status" id="ai-status">Ready</span>
                            </div>
                            <div class="race-cube-container" id="ai-cube-container">
                                <!-- AI's cube rendered here -->
                            </div>
                            <div class="race-stats">
                                <div class="race-stat">
                                    <div class="race-stat-value" id="ai-time">0.00</div>
                                    <div class="race-stat-label">Time</div>
                                </div>
                                <div class="race-stat">
                                    <div class="race-stat-value" id="ai-moves">0</div>
                                    <div class="race-stat-label">Moves</div>
                                </div>
                            </div>
                            <div class="ai-thinking" id="ai-thinking" style="display: none;">
                                <span>Solving</span>
                                <div class="ai-thinking-dots">
                                    <div class="ai-thinking-dot"></div>
                                    <div class="ai-thinking-dot"></div>
                                    <div class="ai-thinking-dot"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="race-result" id="race-result">
                        <div class="race-result-title" id="result-title">YOU WIN!</div>
                        <div class="race-result-details" id="result-details">You solved it in 15.23s with 45 moves</div>
                        <button class="race-again-btn" id="race-again-btn">ðŸ Race Again</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
    // OrbitControls inline for compatibility
    THREE.OrbitControls = function(object, domElement) {
        this.object = object;
        this.domElement = domElement;
        this.enabled = true;
        this.target = new THREE.Vector3();
        this.minDistance = 0;
        this.maxDistance = Infinity;
        this.enableDamping = false;
        this.dampingFactor = 0.05;
        this.enablePan = true;
        
        var scope = this;
        var rotateStart = new THREE.Vector2();
        var rotateEnd = new THREE.Vector2();
        var rotateDelta = new THREE.Vector2();
        var spherical = new THREE.Spherical();
        var sphericalDelta = new THREE.Spherical();
        var scale = 1;
        var zoomChanged = false;
        var STATE = { NONE: -1, ROTATE: 0, DOLLY: 1, PAN: 2 };
        var state = STATE.NONE;
        
        this.update = function() {
            var offset = new THREE.Vector3();
            var position = scope.object.position;
            offset.copy(position).sub(scope.target);
            spherical.setFromVector3(offset);
            if (scope.enableDamping) {
                spherical.theta += sphericalDelta.theta * scope.dampingFactor;
                spherical.phi += sphericalDelta.phi * scope.dampingFactor;
            } else {
                spherical.theta += sphericalDelta.theta;
                spherical.phi += sphericalDelta.phi;
            }
            spherical.phi = Math.max(0.01, Math.min(Math.PI - 0.01, spherical.phi));
            spherical.radius *= scale;
            spherical.radius = Math.max(scope.minDistance, Math.min(scope.maxDistance, spherical.radius));
            offset.setFromSpherical(spherical);
            position.copy(scope.target).add(offset);
            scope.object.lookAt(scope.target);
            if (scope.enableDamping) {
                sphericalDelta.theta *= (1 - scope.dampingFactor);
                sphericalDelta.phi *= (1 - scope.dampingFactor);
            } else {
                sphericalDelta.set(0, 0, 0);
            }
            scale = 1;
            return zoomChanged;
        };
        
        function onMouseDown(event) {
            if (!scope.enabled) return;
            event.preventDefault();
            if (event.button === 0) {
                state = STATE.ROTATE;
                rotateStart.set(event.clientX, event.clientY);
            }
            document.addEventListener('mousemove', onMouseMove, false);
            document.addEventListener('mouseup', onMouseUp, false);
        }
        
        function onMouseMove(event) {
            if (!scope.enabled) return;
            event.preventDefault();
            if (state === STATE.ROTATE) {
                rotateEnd.set(event.clientX, event.clientY);
                rotateDelta.subVectors(rotateEnd, rotateStart);
                sphericalDelta.theta -= 2 * Math.PI * rotateDelta.x / domElement.clientWidth;
                sphericalDelta.phi -= 2 * Math.PI * rotateDelta.y / domElement.clientHeight;
                rotateStart.copy(rotateEnd);
            }
        }
        
        function onMouseUp() {
            if (!scope.enabled) return;
            document.removeEventListener('mousemove', onMouseMove, false);
            document.removeEventListener('mouseup', onMouseUp, false);
            state = STATE.NONE;
        }
        
        function onWheel(event) {
            if (!scope.enabled) return;
            event.preventDefault();
            if (event.deltaY < 0) {
                scale /= 0.95;
            } else if (event.deltaY > 0) {
                scale *= 0.95;
            }
            zoomChanged = true;
        }
        
        domElement.addEventListener('mousedown', onMouseDown, false);
        domElement.addEventListener('wheel', onWheel, { passive: false });
        this.update();
    };
    </script>
    <script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// GLOBAL STATE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const state = {
    scene: null,
    camera: null,
    renderer: null,
    controls: null,
    currentPuzzle: null,
    puzzleType: 'cube',
    cubeSize: 3,
    isAnimating: false,
    moveQueue: [],
    moves: 0,
    timer: 0,
    timerInterval: null,
    isTimerRunning: false,
    isSolved: true,
    raycaster: new THREE.Raycaster(),
    mouse: new THREE.Vector2(),
    isDragging: false,
    dragStart: null,
    selectedFace: null,
    solveSpeed: 200,
    impossibleMode: false,
    bestTimes: JSON.parse(localStorage.getItem('bestTimes')) || {},
    unlockedAchievements: JSON.parse(localStorage.getItem('achievements')) || []
};

const ACHIEVEMENTS = [
    // Time achievements
    { id: 'sub60', name: 'Getting Started', desc: 'Solve a cube in under 60 seconds', icon: 'â±ï¸', check: (time, moves, size, impossible) => time < 60000 },
    { id: 'sub30', name: 'Speed Demon', desc: 'Solve a cube in under 30 seconds', icon: 'ðŸ”¥', check: (time, moves, size, impossible) => time < 30000 },
    { id: 'sub20', name: 'Lightning Fast', desc: 'Solve a cube in under 20 seconds', icon: 'âš¡', check: (time, moves, size, impossible) => time < 20000 },
    { id: 'sub10', name: 'World Class', desc: 'Solve a cube in under 10 seconds', icon: 'ðŸ†', check: (time, moves, size, impossible) => time < 10000 },
    { id: 'sub5', name: 'Inhuman', desc: 'Solve a cube in under 5 seconds', icon: 'ðŸ‘½', check: (time, moves, size, impossible) => time < 5000 },
    
    // Move efficiency
    { id: 'efficient', name: 'Efficient', desc: 'Solve a 3Ã—3 in under 50 moves', icon: 'ðŸŽ¯', check: (time, moves, size, impossible) => size === 3 && moves < 50 },
    { id: 'optimal', name: 'Optimizer', desc: 'Solve a 3Ã—3 in under 30 moves', icon: 'ðŸ’Ž', check: (time, moves, size, impossible) => size === 3 && moves < 30 },
    
    // Cube sizes
    { id: 'tiny', name: 'Baby Steps', desc: 'Solve a 2Ã—2 cube', icon: 'ðŸ‘¶', check: (time, moves, size, impossible) => size === 2 },
    { id: 'classic', name: 'Classic', desc: 'Solve a 3Ã—3 cube', icon: 'ðŸŽ®', check: (time, moves, size, impossible) => size === 3 },
    { id: 'revenge', name: 'Revenge', desc: 'Solve a 4Ã—4 cube', icon: 'ðŸ˜¤', check: (time, moves, size, impossible) => size === 4 },
    { id: 'professor', name: 'Professor', desc: 'Solve a 5Ã—5 cube', icon: 'ðŸŽ“', check: (time, moves, size, impossible) => size === 5 },
    { id: 'big', name: 'Going Big', desc: 'Solve a 7Ã—7 cube', icon: 'ðŸ“¦', check: (time, moves, size, impossible) => size === 7 },
    { id: 'massive', name: 'Massive', desc: 'Solve a 10Ã—10 cube', icon: 'ðŸ”ï¸', check: (time, moves, size, impossible) => size === 10 },
    { id: 'giant', name: 'Giant Slayer', desc: 'Solve a 15Ã—15 cube', icon: 'ðŸ—¿', check: (time, moves, size, impossible) => size === 15 },
    { id: 'insane', name: 'Absolute Madman', desc: 'Solve a 20Ã—20 cube', icon: 'ðŸ¤¯', check: (time, moves, size, impossible) => size === 20 },
    
    // Special
    { id: 'impossible', name: 'Impossible!', desc: 'Solve a cube in Impossible mode', icon: 'ðŸŒˆ', check: (time, moves, size, impossible) => impossible },
    { id: 'impossible_sub60', name: 'Color Blind', desc: 'Solve Impossible mode in under 60 seconds', icon: 'ðŸ‘ï¸', check: (time, moves, size, impossible) => impossible && time < 60000 },
    { id: 'race_winner', name: 'Speed Racer', desc: 'Beat the AI on Hard or Insane difficulty', icon: 'ðŸ', check: () => state.unlockedAchievements?.includes('race_winner') },
    { id: 'first', name: 'First Solve', desc: 'Complete your first solve', icon: 'ðŸŒŸ', check: () => true },
    { id: 'dedicated', name: 'Dedicated', desc: 'Solve 10 cubes total', icon: 'ðŸ’ª', check: () => (parseInt(localStorage.getItem('totalSolves')) || 0) >= 10 },
    { id: 'addict', name: 'Cube Addict', desc: 'Solve 50 cubes total', icon: 'ðŸŽª', check: () => (parseInt(localStorage.getItem('totalSolves')) || 0) >= 50 },
    { id: 'master', name: 'Cube Master', desc: 'Solve 100 cubes total', icon: 'ðŸ‘‘', check: () => (parseInt(localStorage.getItem('totalSolves')) || 0) >= 100 },
];

// Color arrays for Impossible mode - each face cycles through multiple confusing colors
const IMPOSSIBLE_COLORS = {
    white:  [0xffffff, 0xffd500, 0xff5800, 0xc41e3a, 0x0051ba],   // white cycles through yellow, orange, red, blue
    yellow: [0xffd500, 0x009e60, 0xffffff, 0xff5800, 0xc41e3a],   // yellow cycles through green, white, orange, red
    red:    [0xc41e3a, 0xff5800, 0x0051ba, 0xffd500, 0x009e60],   // red cycles through orange, blue, yellow, green
    orange: [0xff5800, 0xc41e3a, 0xffffff, 0x0051ba, 0x009e60],   // orange cycles through red, white, blue, green
    blue:   [0x0051ba, 0x009e60, 0xc41e3a, 0xffffff, 0xffd500],   // blue cycles through green, red, white, yellow
    green:  [0x009e60, 0x0051ba, 0xffd500, 0xc41e3a, 0xff5800]    // green cycles through blue, yellow, red, orange
};

const COLORS = {
    white: 0xffffff,
    yellow: 0xffd500,
    red: 0xc41e3a,
    orange: 0xff5800,
    blue: 0x0051ba,
    green: 0x009e60,
    black: 0x111111
};

const THEMES = [
    {
        id: 'cyber',
        name: 'Neon Cyber',
        colors: ['#00f5ff', '#ff00aa', '#0066ff', '#ffcc00', '#ff3300', '#00cc44'],
        bgColor: '#0a0a0f',
        locked: false
    },
    {
        id: 'sunset',
        name: 'Sunset Blaze',
        colors: ['#ff6b35', '#f7931e', '#ff4757', '#ffcc02', '#ff8800', '#2d1b69'],
        bgColor: '#1a0a0a',
        locked: true
    },
    {
        id: 'forest',
        name: 'Forest Moss',
        colors: ['#4ade80', '#22c55e', '#a3e635', '#10b981', '#059669', '#047857'],
        bgColor: '#0a1a0a',
        locked: true
    },
    {
        id: 'galaxy',
        name: 'Galaxy Purple',
        colors: ['#a855f7', '#ec4899', '#f472b6', '#c084fc', '#8b5cf6', '#7c3aed'],
        bgColor: '#0f0a1a',
        locked: true
    },
    {
        id: 'ocean',
        name: 'Ocean Deep',
        colors: ['#06b6d4', '#0ea5e9', '#38bdf8', '#22d3ee', '#0891b2', '#0284c7'],
        bgColor: '#0a0f1a',
        locked: true
    },
    {
        id: 'retro',
        name: 'Retro Arcade',
        colors: ['#39ff14', '#ff073a', '#fff01f', '#00ff00', '#ff00ff', '#00ffff'],
        bgColor: '#000000',
        locked: true
    },
    {
        id: 'pastel',
        name: 'Pastel Dream',
        colors: ['#f9a8d4', '#c084fc', '#fbbf24', '#86efac', '#93c5fd', '#fdba74'],
        bgColor: '#fef7ff',
        locked: true
    },
    {
        id: 'mono',
        name: 'Monochrome',
        colors: ['#ffffff', '#cccccc', '#999999', '#666666', '#333333', '#000000'],
        bgColor: '#0a0a0a',
        locked: true
    },
    // Retro Gaming Themes - Require watching ads to unlock
    {
        id: 'gameboy',
        name: 'ðŸŽ® Game Boy',
        colors: ['#9bbc0f', '#8bac0f', '#306230', '#0f380f', '#9bbc0f', '#306230'],
        bgColor: '#9bbc0f',
        locked: true,
        requiresAds: true
    },
    {
        id: 'nes',
        name: 'ðŸ•¹ï¸ NES Classic',
        colors: ['#fcfcfc', '#f83800', '#0058f8', '#00a800', '#ffa044', '#58d854'],
        bgColor: '#000000',
        locked: true,
        requiresAds: true
    },
    {
        id: 'snes',
        name: 'ðŸŽ® SNES',
        colors: ['#b5b5b5', '#7e3d7e', '#1d3dfc', '#d82800', '#ffa044', '#00a800'],
        bgColor: '#2f2a3e',
        locked: true,
        requiresAds: true
    },
    {
        id: 'virtualboy',
        name: 'ðŸ‘“ Virtual Boy',
        colors: ['#ff0000', '#aa0000', '#660000', '#ff3333', '#cc0000', '#880000'],
        bgColor: '#000000',
        locked: true,
        requiresAds: true
    },
    {
        id: 'n64',
        name: 'ðŸŽ® N64',
        colors: ['#e60012', '#009e60', '#0055a4', '#ffd400', '#ff6600', '#00a0e9'],
        bgColor: '#1a1a2e',
        locked: true,
        requiresAds: true
    }
];

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INITIALIZATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function init() {
    state.scene = new THREE.Scene();
    
    // Apply theme background
    const savedTheme = localStorage.getItem('currentTheme') || 'cyber';
    const theme = THEMES.find(t => t.id === savedTheme) || THEMES[0];
    state.scene.background = new THREE.Color(theme.bgColor);
    
    state.camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
    state.camera.position.set(5, 5, 7);
    
    const canvas = document.getElementById('puzzle-canvas');
    state.renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
    state.renderer.setSize(window.innerWidth, window.innerHeight);
    state.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    
    state.controls = new THREE.OrbitControls(state.camera, canvas);
    state.controls.enableDamping = true;
    state.controls.dampingFactor = 0.05;
    state.controls.enablePan = false;
    state.controls.minDistance = 3;
    state.controls.maxDistance = 50;
    
    setupLighting();
    createPuzzle('cube', 3);
    setupEventListeners();
    
    animate();
}

function setupLighting() {
    const ambient = new THREE.AmbientLight(0xffffff, 0.6);
    state.scene.add(ambient);
    
    const mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
    mainLight.position.set(5, 10, 7);
    state.scene.add(mainLight);
    
    const fillLight = new THREE.DirectionalLight(0x4488ff, 0.3);
    fillLight.position.set(-5, 0, -5);
    state.scene.add(fillLight);
    
    const rimLight = new THREE.DirectionalLight(0xff4488, 0.2);
    rimLight.position.set(0, -5, 5);
    state.scene.add(rimLight);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// RUBIK'S CUBE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class RubiksCube {
    constructor(size = 3) {
        this.size = size;
        this.group = new THREE.Group();
        this.cubies = [];
        this.rotationGroup = new THREE.Group();
        this.cubeSize = size > 10 ? 10 / size : 1;
        this.gap = 0.08;
        
        this.createCube();
        state.scene.add(this.group);
        state.scene.add(this.rotationGroup);
        
        const dist = Math.max(5, size * 0.8);
        state.camera.position.set(dist, dist, dist * 1.2);
        state.controls.minDistance = size * 0.5;
        state.controls.maxDistance = size * 5;
    }
    
    createCube() {
        const offset = (this.size - 1) / 2;
        
        for (let x = 0; x < this.size; x++) {
            for (let y = 0; y < this.size; y++) {
                for (let z = 0; z < this.size; z++) {
                    if (x === 0 || x === this.size - 1 ||
                        y === 0 || y === this.size - 1 ||
                        z === 0 || z === this.size - 1) {
                        
                        const cubie = this.createCubie(x, y, z, offset);
                        cubie.userData = { x, y, z };
                        this.cubies.push(cubie);
                        this.group.add(cubie);
                    }
                }
            }
        }
    }
    
    createCubie(x, y, z, offset) {
        const size = this.cubeSize - this.gap;
        
        // Create a group for this cubie
        const cubieGroup = new THREE.Group();
        
        // Black core cube (slightly smaller)
        const coreSize = size * 0.98;
        const coreGeo = new THREE.BoxGeometry(coreSize, coreSize, coreSize);
        const coreMat = new THREE.MeshLambertMaterial({ color: 0x111111 });
        const core = new THREE.Mesh(coreGeo, coreMat);
        cubieGroup.add(core);
        
        // Add colored sticker faces on top
        const stickerSize = size * 0.85;
        const stickerThickness = 0.02;
        const stickerOffset = size / 2 + 0.001;
        
        // Right face (+X) - Red
        if (x === this.size - 1) {
            const sticker = this.createSticker(stickerSize, stickerThickness, COLORS.red, 'red', new THREE.Vector3(1, 0, 0));
            sticker.position.set(stickerOffset, 0, 0);
            sticker.rotation.y = Math.PI / 2;
            cubieGroup.add(sticker);
        }
        
        // Left face (-X) - Orange
        if (x === 0) {
            const sticker = this.createSticker(stickerSize, stickerThickness, COLORS.orange, 'orange', new THREE.Vector3(-1, 0, 0));
            sticker.position.set(-stickerOffset, 0, 0);
            sticker.rotation.y = -Math.PI / 2;
            cubieGroup.add(sticker);
        }
        
        // Top face (+Y) - White
        if (y === this.size - 1) {
            const sticker = this.createSticker(stickerSize, stickerThickness, COLORS.white, 'white', new THREE.Vector3(0, 1, 0));
            sticker.position.set(0, stickerOffset, 0);
            sticker.rotation.x = -Math.PI / 2;
            cubieGroup.add(sticker);
        }
        
        // Bottom face (-Y) - Yellow
        if (y === 0) {
            const sticker = this.createSticker(stickerSize, stickerThickness, COLORS.yellow, 'yellow', new THREE.Vector3(0, -1, 0));
            sticker.position.set(0, -stickerOffset, 0);
            sticker.rotation.x = Math.PI / 2;
            cubieGroup.add(sticker);
        }
        
        // Front face (+Z) - Blue
        if (z === this.size - 1) {
            const sticker = this.createSticker(stickerSize, stickerThickness, COLORS.blue, 'blue', new THREE.Vector3(0, 0, 1));
            sticker.position.set(0, 0, stickerOffset);
            cubieGroup.add(sticker);
        }
        
        // Back face (-Z) - Green
        if (z === 0) {
            const sticker = this.createSticker(stickerSize, stickerThickness, COLORS.green, 'green', new THREE.Vector3(0, 0, -1));
            sticker.position.set(0, 0, -stickerOffset);
            sticker.rotation.y = Math.PI;
            cubieGroup.add(sticker);
        }
        
        cubieGroup.position.set(
            (x - offset) * this.cubeSize,
            (y - offset) * this.cubeSize,
            (z - offset) * this.cubeSize
        );
        
        return cubieGroup;
    }
    
    createSticker(size, thickness, color, colorName, faceNormal) {
        // Rounded rectangle sticker
        const shape = new THREE.Shape();
        const radius = size * 0.15;
        const halfSize = size / 2;
        
        shape.moveTo(-halfSize + radius, -halfSize);
        shape.lineTo(halfSize - radius, -halfSize);
        shape.quadraticCurveTo(halfSize, -halfSize, halfSize, -halfSize + radius);
        shape.lineTo(halfSize, halfSize - radius);
        shape.quadraticCurveTo(halfSize, halfSize, halfSize - radius, halfSize);
        shape.lineTo(-halfSize + radius, halfSize);
        shape.quadraticCurveTo(-halfSize, halfSize, -halfSize, halfSize - radius);
        shape.lineTo(-halfSize, -halfSize + radius);
        shape.quadraticCurveTo(-halfSize, -halfSize, -halfSize + radius, -halfSize);
        
        const geometry = new THREE.ShapeGeometry(shape);
        const material = new THREE.MeshPhongMaterial({ 
            color: color,
            shininess: 80,
            specular: 0x333333
        });
        
        const mesh = new THREE.Mesh(geometry, material);
        
        // Store data for impossible mode
        mesh.userData.colorName = colorName;
        mesh.userData.baseColor = color;
        mesh.userData.faceNormal = faceNormal;
        mesh.userData.isSticker = true;
        
        return mesh;
    }
    
    getFaceMaterial(color) {
        if (color === null) {
            return new THREE.MeshLambertMaterial({ color: COLORS.black });
        }
        return new THREE.MeshPhongMaterial({ color, shininess: 30, specular: 0x444444 });
    }
    
    async rotate(axis, layer, direction, animate = true) {
        if (state.isAnimating) {
            state.moveQueue.push({ axis, layer, direction });
            return;
        }
        
        state.isAnimating = true;
        
        // Initialize move history if needed
        if (!this.moveHistory) this.moveHistory = [];
        
        // Track this move for auto-solve (only for manual moves, not during scramble)
        if (animate) {
            this.moveHistory.push({ axis, layer, direction });
        }
        
        // Start timer on first manual move
        if (!state.isTimerRunning && animate) {
            startTimer();
            this.scrambled = true; // Mark as scrambled so solve detection works
        }
        
        state.moves++;
        updateMoveDisplay();
        
        const cubiesInLayer = this.getCubiesInLayer(axis, layer);
        
        cubiesInLayer.forEach(cubie => {
            this.group.remove(cubie);
            this.rotationGroup.add(cubie);
        });
        
        const angle = (Math.PI / 2) * direction;
        
        if (animate) {
            await this.animateRotation(axis, angle);
        } else {
            this.rotationGroup.rotation[axis] = angle;
        }
        
        // Apply rotation to each cubie
        const rotAxis = new THREE.Vector3(
            axis === 'x' ? 1 : 0,
            axis === 'y' ? 1 : 0,
            axis === 'z' ? 1 : 0
        );
        const quaternion = new THREE.Quaternion().setFromAxisAngle(rotAxis, angle);
        
        cubiesInLayer.forEach(cubie => {
            cubie.updateMatrixWorld();
            const worldPos = new THREE.Vector3();
            cubie.getWorldPosition(worldPos);
            
            const worldQuat = new THREE.Quaternion();
            cubie.getWorldQuaternion(worldQuat);
            
            this.rotationGroup.remove(cubie);
            this.group.add(cubie);
            
            cubie.position.copy(worldPos);
            cubie.quaternion.copy(worldQuat);
            
            this.updateCubiePosition(cubie);
        });
        
        this.rotationGroup.rotation.set(0, 0, 0);
        state.isAnimating = false;
        
        // Only check solved if we've been scrambled and timer is running
        if (this.scrambled && state.isTimerRunning && this.isSolved()) {
            state.isSolved = true;
            this.scrambled = false;
            stopTimer();
            showSolvedModal();
        }
        
        if (state.moveQueue.length > 0) {
            const next = state.moveQueue.shift();
            this.rotate(next.axis, next.layer, next.direction);
        }
    }
    
    getCubiesInLayer(axis, layer) {
        const offset = (this.size - 1) / 2;
        const threshold = this.cubeSize * 0.4; // Scale threshold with cube size
        
        return this.cubies.filter(cubie => {
            const pos = cubie.position.clone();
            const layerPos = (layer - offset) * this.cubeSize;
            
            switch (axis) {
                case 'x': return Math.abs(pos.x - layerPos) < threshold;
                case 'y': return Math.abs(pos.y - layerPos) < threshold;
                case 'z': return Math.abs(pos.z - layerPos) < threshold;
            }
            return false;
        });
    }
    
    async animateRotation(axis, angle) {
        return new Promise(resolve => {
            const duration = state.solveSpeed; // Use global solve speed
            const startTime = Date.now();
            const startRotation = this.rotationGroup.rotation[axis];
            
            const animateStep = () => {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const eased = 1 - Math.pow(1 - progress, 3);
                
                this.rotationGroup.rotation[axis] = startRotation + angle * eased;
                
                if (progress < 1) {
                    requestAnimationFrame(animateStep);
                } else {
                    resolve();
                }
            };
            
            animateStep();
        });
    }
    
    async animateToSolved() {
        state.isAnimating = true;
        stopTimer();
        
        const offset = (this.size - 1) / 2;
        const duration = 500;
        const startTime = Date.now();
        
        // Store starting positions and rotations
        const startStates = this.cubies.map(cubie => ({
            cubie,
            startPos: cubie.position.clone(),
            startQuat: cubie.quaternion.clone(),
            targetPos: new THREE.Vector3(
                (cubie.userData.x - offset) * this.cubeSize,
                (cubie.userData.y - offset) * this.cubeSize,
                (cubie.userData.z - offset) * this.cubeSize
            ),
            // Calculate original position from userData
            origX: cubie.userData.x,
            origY: cubie.userData.y,
            origZ: cubie.userData.z
        }));
        
        // Recalculate target positions based on original grid coords
        startStates.forEach(state => {
            state.targetPos = new THREE.Vector3(
                (state.origX - offset) * this.cubeSize,
                (state.origY - offset) * this.cubeSize,
                (state.origZ - offset) * this.cubeSize
            );
        });
        
        return new Promise(resolve => {
            const animate = () => {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const eased = 1 - Math.pow(1 - progress, 3);
                
                startStates.forEach(({ cubie, startPos, startQuat, targetPos }) => {
                    // Interpolate position
                    cubie.position.lerpVectors(startPos, targetPos, eased);
                    
                    // Interpolate rotation back to identity
                    cubie.quaternion.slerpQuaternions(startQuat, new THREE.Quaternion(), eased);
                });
                
                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    // Snap to exact positions
                    startStates.forEach(({ cubie, targetPos }) => {
                        cubie.position.copy(targetPos);
                        cubie.quaternion.identity();
                    });
                    
                    this.scrambled = false;
                    this.moveHistory = [];
                    state.isAnimating = false;
                    state.isSolved = true;
                    state.moves = 0;
                    resetTimer();
                    updateMoveDisplay();
                    showSolvedModal();
                    resolve();
                }
            };
            animate();
        });
    }
    
    updateCubiePosition(cubie) {
        const offset = (this.size - 1) / 2;
        
        // Snap position to valid grid positions
        // Valid positions are: (i - offset) * cubeSize for i in 0..size-1
        const snapToGrid = (val) => {
            // Find the closest grid index
            const gridIndex = Math.round(val / this.cubeSize + offset);
            const clampedIndex = Math.max(0, Math.min(this.size - 1, gridIndex));
            return (clampedIndex - offset) * this.cubeSize;
        };
        
        cubie.position.x = snapToGrid(cubie.position.x);
        cubie.position.y = snapToGrid(cubie.position.y);
        cubie.position.z = snapToGrid(cubie.position.z);
        
        // Update userData - calculate grid coordinates from position
        cubie.userData.x = Math.round(cubie.position.x / this.cubeSize + offset);
        cubie.userData.y = Math.round(cubie.position.y / this.cubeSize + offset);
        cubie.userData.z = Math.round(cubie.position.z / this.cubeSize + offset);
    }
    
    isSolved() {
        // Check if cube was scrambled first
        if (this.scrambled === false) {
            return true; // Fresh cube is solved
        }
        
        // Check each cubie's rotation - if any cubie has been rotated, cube isn't solved
        const threshold = 0.05;
        for (const cubie of this.cubies) {
            // Get the cubie's world quaternion
            const worldQuat = new THREE.Quaternion();
            cubie.getWorldQuaternion(worldQuat);
            
            // Check if quaternion is close to identity (no rotation)
            const identity = new THREE.Quaternion();
            const dot = Math.abs(worldQuat.dot(identity));
            
            // dot should be very close to 1 for identity quaternion
            if (dot < 0.999) {
                return false;
            }
        }
        return true;
    }
    
    scramble(moves = null) {
        // Use animated scramble by default
        this.animatedScramble(moves);
    }
    
    async animatedScramble(moves = null) {
        if (state.isAnimating) return;
        
        if (moves === null) moves = Math.max(20, this.size * 5);
        
        // Reset cube first
        this.reset();
        
        this.scrambled = true;
        state.isSolved = false;
        this.moveHistory = []; // Track moves for solving
        
        state.isAnimating = true;
        
        const axes = ['x', 'y', 'z'];
        const directions = [1, -1];
        
        // Generate all scramble moves first
        const scrambleMoves = [];
        for (let i = 0; i < moves; i++) {
            const axis = axes[Math.floor(Math.random() * 3)];
            const layer = Math.floor(Math.random() * this.size);
            const direction = directions[Math.floor(Math.random() * 2)];
            scrambleMoves.push({ axis, layer, direction });
        }
        
        // Animate each move with faster animation for scrambling
        for (const move of scrambleMoves) {
            // Track the move for solving
            this.moveHistory.push(move);
            
            // Get cubies in layer
            const cubiesInLayer = this.getCubiesInLayer(move.axis, move.layer);
            if (cubiesInLayer.length === 0) continue;
            
            // Move to rotation group
            cubiesInLayer.forEach(cubie => {
                this.group.remove(cubie);
                this.rotationGroup.add(cubie);
            });
            
            // Fast animation for scramble (50ms per move)
            const angle = (Math.PI / 2) * move.direction;
            await this.animateRotationFast(move.axis, angle, 50);
            
            // Apply rotation to cubies
            const rotAxis = new THREE.Vector3(
                move.axis === 'x' ? 1 : 0,
                move.axis === 'y' ? 1 : 0,
                move.axis === 'z' ? 1 : 0
            );
            
            cubiesInLayer.forEach(cubie => {
                cubie.updateMatrixWorld();
                const worldPos = new THREE.Vector3();
                cubie.getWorldPosition(worldPos);
                const worldQuat = new THREE.Quaternion();
                cubie.getWorldQuaternion(worldQuat);
                
                this.rotationGroup.remove(cubie);
                this.group.add(cubie);
                
                cubie.position.copy(worldPos);
                cubie.quaternion.copy(worldQuat);
                this.updateCubiePosition(cubie);
            });
            
            this.rotationGroup.rotation.set(0, 0, 0);
        }
        
        state.isAnimating = false;
        state.moves = 0;
        resetTimer();
        updateMoveDisplay();
    }
    
    async animateRotationFast(axis, angle, duration = 50) {
        return new Promise(resolve => {
            const startTime = Date.now();
            const startRotation = this.rotationGroup.rotation[axis];
            
            const animateStep = () => {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const eased = 1 - Math.pow(1 - progress, 2); // Ease out quad (faster)
                
                this.rotationGroup.rotation[axis] = startRotation + angle * eased;
                
                if (progress < 1) {
                    requestAnimationFrame(animateStep);
                } else {
                    resolve();
                }
            };
            
            animateStep();
        });
    }
    
    instantScramble(moves = null) {
        // Keep the old instant scramble available if needed
        if (moves === null) moves = Math.max(20, this.size * 5);
        
        // Reset cube first
        this.reset();
        
        this.scrambled = true;
        state.isSolved = false;
        this.moveHistory = []; // Track moves for solving
        
        const axes = ['x', 'y', 'z'];
        const directions = [1, -1];
        
        // Do scramble moves without animation
        for (let i = 0; i < moves; i++) {
            const axis = axes[Math.floor(Math.random() * 3)];
            const layer = Math.floor(Math.random() * this.size);
            const direction = directions[Math.floor(Math.random() * 2)];
            
            // Track the move
            this.moveHistory.push({ axis, layer, direction });
            
            // Directly rotate without triggering solve check
            this.doRotation(axis, layer, direction);
        }
        
        state.moves = 0;
        resetTimer();
        updateMoveDisplay();
    }
    
    async animatedSolve() {
        if (state.isAnimating) return;
        
        // If no move history (manually scrambled), just animate back to solved
        if (!this.moveHistory || this.moveHistory.length === 0) {
            await this.animateToSolved();
            return;
        }
        
        state.isAnimating = true;
        stopTimer();
        
        try {
            // Reverse the move history and play back with animation
            const reversedMoves = [...this.moveHistory].reverse();
            
            for (const move of reversedMoves) {
                // Reverse the direction
                const reverseDirection = -move.direction;
                
                // Get cubies in layer
                const cubiesInLayer = this.getCubiesInLayer(move.axis, move.layer);
                if (cubiesInLayer.length === 0) {
                    console.warn(`No cubies found for layer ${move.axis}=${move.layer}`);
                    continue;
                }
                
                // Move to rotation group
                cubiesInLayer.forEach(cubie => {
                    this.group.remove(cubie);
                    this.rotationGroup.add(cubie);
                });
                
                const angle = (Math.PI / 2) * reverseDirection;
                
                // Animate
                await this.animateRotation(move.axis, angle);
                
                // Apply rotation and move back
                cubiesInLayer.forEach(cubie => {
                    cubie.updateMatrixWorld();
                    const worldPos = new THREE.Vector3();
                    cubie.getWorldPosition(worldPos);
                    const worldQuat = new THREE.Quaternion();
                    cubie.getWorldQuaternion(worldQuat);
                    
                    this.rotationGroup.remove(cubie);
                    this.group.add(cubie);
                    
                    cubie.position.copy(worldPos);
                    cubie.quaternion.copy(worldQuat);
                    this.updateCubiePosition(cubie);
                });
                
                this.rotationGroup.rotation.set(0, 0, 0);
            }
            
            // Clear history and mark as solved
            this.moveHistory = [];
            this.scrambled = false;
            state.isSolved = true;
            state.moves = 0;
            resetTimer();
            updateMoveDisplay();
            
            // Show solved celebration
            showSolvedModal();
        } catch (error) {
            console.error('Error during auto-solve:', error);
        } finally {
            // Always reset animation state
            state.isAnimating = false;
        }
    }
    
    doRotation(axis, layer, direction) {
        const cubiesInLayer = this.getCubiesInLayer(axis, layer);
        if (cubiesInLayer.length === 0) return;
        
        const angle = (Math.PI / 2) * direction;
        
        // Create rotation quaternion
        const rotAxis = new THREE.Vector3(
            axis === 'x' ? 1 : 0,
            axis === 'y' ? 1 : 0,
            axis === 'z' ? 1 : 0
        );
        const quaternion = new THREE.Quaternion().setFromAxisAngle(rotAxis, angle);
        
        cubiesInLayer.forEach(cubie => {
            // Rotate position around axis
            cubie.position.applyQuaternion(quaternion);
            
            // Rotate the cubie itself
            cubie.quaternion.premultiply(quaternion);
            
            // Snap to grid and update userData
            this.updateCubiePosition(cubie);
        });
    }
    
    reset() {
        // Stop any ongoing animation
        state.isAnimating = false;
        state.moveQueue = [];
        
        // Clear cubies from BOTH groups (some might be in rotationGroup during animation)
        this.cubies.forEach(cubie => {
            cubie.traverse(child => {
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
            });
            this.group.remove(cubie);
            this.rotationGroup.remove(cubie);
        });
        
        // Reset rotation group
        this.rotationGroup.rotation.set(0, 0, 0);
        
        // Clear state
        this.cubies = [];
        this.scrambled = false;
        this.moveHistory = [];
        
        // Recreate cube
        this.createCube();
        
        state.isSolved = true;
        state.moves = 0;
        resetTimer();
        updateMoveDisplay();
    }
    
    destroy() {
        // Stop any ongoing animation
        state.isAnimating = false;
        state.moveQueue = [];
        
        // Clear cubies from BOTH groups
        this.cubies.forEach(cubie => {
            cubie.traverse(child => {
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
            });
            this.group.remove(cubie);
            this.rotationGroup.remove(cubie);
        });
        
        state.scene.remove(this.group);
        state.scene.remove(this.rotationGroup);
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PUZZLE FACTORY
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function createPuzzle(type, size = 3) {
    // Clean up old puzzle
    if (state.currentPuzzle) {
        try {
            state.currentPuzzle.destroy();
        } catch(e) {
            console.log('Cleanup error:', e);
        }
    }
    state.currentPuzzle = null;
    
    // Clear any leftover objects from scene
    while(state.scene.children.length > 0) {
        const obj = state.scene.children[0];
        state.scene.remove(obj);
    }
    
    // Re-add lighting
    setupLighting();
    
    state.puzzleType = type;
    state.cubeSize = size;
    state.moves = 0;
    state.isSolved = true;
    resetTimer();
    updateMoveDisplay();
    
    // Create new puzzle
    try {
        state.currentPuzzle = new RubiksCube(size);
    } catch(e) {
        console.log('Create error:', e);
        state.currentPuzzle = new RubiksCube(3);
    }
    
    // Update best time display for this puzzle
    updateBestTimeDisplay();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INTERACTION HANDLING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function setupEventListeners() {
    const canvas = document.getElementById('puzzle-canvas');
    
    canvas.addEventListener('mousedown', onMouseDown);
    canvas.addEventListener('mousemove', onMouseMove);
    canvas.addEventListener('mouseup', onMouseUp);
    canvas.addEventListener('touchstart', onTouchStart, { passive: false });
    canvas.addEventListener('touchmove', onTouchMove, { passive: false });
    canvas.addEventListener('touchend', onTouchEnd);
    
    document.addEventListener('keydown', onKeyDown);
    window.addEventListener('resize', onWindowResize);
    
    document.getElementById('scramble-btn').addEventListener('click', () => {
        if (state.currentPuzzle) state.currentPuzzle.scramble();
    });
    
    document.getElementById('reset-btn').addEventListener('click', () => {
        if (state.currentPuzzle) state.currentPuzzle.reset();
    });
    
    document.getElementById('solve-btn').addEventListener('click', () => {
        if (state.currentPuzzle && state.currentPuzzle.animatedSolve) {
            state.currentPuzzle.animatedSolve();
        } else if (state.currentPuzzle) {
            state.currentPuzzle.reset();
        }
    });
    
    document.getElementById('play-again-btn').addEventListener('click', () => {
        document.getElementById('solved-modal').classList.add('hidden');
        if (state.currentPuzzle) state.currentPuzzle.scramble();
    });
    
    document.getElementById('close-solved-btn').addEventListener('click', () => {
        document.getElementById('solved-modal').classList.add('hidden');
    });
    
    // Cube size controls
    const cubeSizeInput = document.getElementById('cube-size-input');
    const cubeSizeInput2 = document.getElementById('cube-size-input2');
    const cubeSizeInput3 = document.getElementById('cube-size-input3');
    const applyBtn = document.getElementById('apply-size-btn');
    
    const applyCubeSize = () => {
        const size = parseInt(cubeSizeInput.value) || 3;
        createPuzzle('cube', Math.max(1, Math.min(30, size)));
    };
    
    cubeSizeInput.addEventListener('input', (e) => {
        const size = parseInt(e.target.value) || 3;
        cubeSizeInput2.value = size;
        cubeSizeInput3.value = size;
    });
    

    
    applyBtn.addEventListener('click', applyCubeSize);
    
    cubeSizeInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') applyCubeSize();
    });
    
    // Solve speed control
    const solveSpeedSlider = document.getElementById('solve-speed');
    const speedDisplay = document.getElementById('speed-display');
    
    solveSpeedSlider.addEventListener('input', (e) => {
        // Invert the value so left is slow, right is fast
        const rawValue = parseInt(e.target.value);
        state.solveSpeed = 550 - rawValue; // 500->50ms (fast), 50->500ms (slow)
        speedDisplay.textContent = state.solveSpeed;
    });
    
    // Impossible mode toggle
    const impossibleBtn = document.getElementById('impossible-btn');
    
    impossibleBtn.addEventListener('click', () => {
        state.impossibleMode = !state.impossibleMode;
        impossibleBtn.classList.toggle('active', state.impossibleMode);
        
        // Reset sticker colors when disabling impossible mode
        if (!state.impossibleMode && state.currentPuzzle) {
            state.currentPuzzle.cubies.forEach(cubie => {
                cubie.traverse(child => {
                    if (child.userData && child.userData.isSticker) {
                        child.material.color.setHex(child.userData.baseColor);
                    }
                });
            });
        }
    });
}
    

function onMouseDown(event) {
    if (event.button !== 0) return;
    
    state.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    state.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
    
    state.raycaster.setFromCamera(state.mouse, state.camera);
    
    if (state.currentPuzzle && state.currentPuzzle.cubies) {
        // Get all meshes from cubie groups
        const allMeshes = [];
        state.currentPuzzle.cubies.forEach(cubie => {
            cubie.traverse(child => {
                if (child.isMesh) {
                    child.userData.parentCubie = cubie;
                    allMeshes.push(child);
                }
            });
        });
        
        const intersects = state.raycaster.intersectObjects(allMeshes);
        
        if (intersects.length > 0) {
            state.isDragging = true;
            state.dragStart = { x: event.clientX, y: event.clientY };
            state.selectedFace = intersects[0];
            state.selectedFace.cubie = intersects[0].object.userData.parentCubie;
            state.controls.enabled = false;
        }
    }
}

function onMouseMove(event) {
    if (!state.isDragging || !state.selectedFace) return;
    
    const dx = event.clientX - state.dragStart.x;
    const dy = event.clientY - state.dragStart.y;
    const threshold = 30;
    
    if (Math.abs(dx) > threshold || Math.abs(dy) > threshold) {
        if (state.puzzleType === 'cube' && state.selectedFace.cubie) {
            const cubie = state.selectedFace.cubie;
            const { x, y, z } = cubie.userData;
            
            // Determine rotation based on drag direction
            let axis, layer, direction;
            
            // Get camera direction to determine which face we're looking at
            const cameraDir = new THREE.Vector3();
            state.camera.getWorldDirection(cameraDir);
            
            // Simple approach: use drag direction
            if (Math.abs(dx) > Math.abs(dy)) {
                // Horizontal drag - rotate around Y axis
                axis = 'y';
                layer = y;
                direction = dx > 0 ? -1 : 1;
            } else {
                // Vertical drag - rotate around X or Z based on camera
                if (Math.abs(cameraDir.x) > Math.abs(cameraDir.z)) {
                    axis = 'z';
                    layer = z;
                    direction = dy > 0 ? 1 : -1;
                } else {
                    axis = 'x';
                    layer = x;
                    direction = dy > 0 ? 1 : -1;
                }
            }
            
            state.currentPuzzle.rotate(axis, layer, direction);
        }
        
        state.isDragging = false;
        state.selectedFace = null;
        state.controls.enabled = true;
    }
}

function onMouseUp() {
    state.isDragging = false;
    state.selectedFace = null;
    state.controls.enabled = true;
}

function onTouchStart(event) {
    if (event.touches.length === 1) {
        event.preventDefault();
        const touch = event.touches[0];
        onMouseDown({ button: 0, clientX: touch.clientX, clientY: touch.clientY });
    }
}

function onTouchMove(event) {
    if (event.touches.length === 1) {
        event.preventDefault();
        const touch = event.touches[0];
        onMouseMove({ clientX: touch.clientX, clientY: touch.clientY });
    }
}

function onTouchEnd() { onMouseUp(); }

function onKeyDown(event) {
    if (!state.currentPuzzle || state.puzzleType !== 'cube') return;
    
    const shift = event.shiftKey;
    const direction = shift ? -1 : 1;
    const size = state.currentPuzzle.size;
    
    switch (event.key.toUpperCase()) {
        case 'U': state.currentPuzzle.rotate('y', size - 1, direction); break;
        case 'D': state.currentPuzzle.rotate('y', 0, -direction); break;
        case 'R': state.currentPuzzle.rotate('x', size - 1, direction); break;
        case 'L': state.currentPuzzle.rotate('x', 0, -direction); break;
        case 'F': state.currentPuzzle.rotate('z', size - 1, direction); break;
        case 'B': state.currentPuzzle.rotate('z', 0, -direction); break;
        case 'M': if (size >= 3) state.currentPuzzle.rotate('x', Math.floor(size / 2), -direction); break;
        case 'E': if (size >= 3) state.currentPuzzle.rotate('y', Math.floor(size / 2), -direction); break;
        case 'S': if (size >= 3) state.currentPuzzle.rotate('z', Math.floor(size / 2), direction); break;
    }
}

function onWindowResize() {
    state.camera.aspect = window.innerWidth / window.innerHeight;
    state.camera.updateProjectionMatrix();
    state.renderer.setSize(window.innerWidth, window.innerHeight);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TIMER & DISPLAY
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function startTimer() {
    state.isTimerRunning = true;
    state.timer = 0;
    const startTime = Date.now();
    
    state.timerInterval = setInterval(() => {
        state.timer = Date.now() - startTime;
        updateTimerDisplay();
    }, 10);
}

function stopTimer() {
    state.isTimerRunning = false;
    if (state.timerInterval) {
        clearInterval(state.timerInterval);
        state.timerInterval = null;
    }
}

function resetTimer() {
    stopTimer();
    state.timer = 0;
    updateTimerDisplay();
}

function updateTimerDisplay() {
    const ms = state.timer % 1000;
    const seconds = Math.floor(state.timer / 1000) % 60;
    const minutes = Math.floor(state.timer / 60000);
    
    document.getElementById('timer').textContent = 
        `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}.${String(Math.floor(ms / 10)).padStart(2, '0')}`;
}

function updateMoveDisplay() {
    document.getElementById('moves').textContent = state.moves;
}

function showSolvedModal() {
    const modal = document.getElementById('solved-modal');
    const timeText = document.getElementById('timer').textContent;
    document.getElementById('final-time').textContent = timeText;
    document.getElementById('final-moves').textContent = state.moves;
    
    // Check for new best time
    const currentTime = state.timer;
    const cubeKey = `cube_${state.cubeSize}x${state.cubeSize}${state.impossibleMode ? '_impossible' : ''}`;
    const bestTime = state.bestTimes[cubeKey];
    
    const recordLabel = document.getElementById('record-label');
    
    if (!bestTime || currentTime < bestTime) {
        // New record!
        state.bestTimes[cubeKey] = currentTime;
        localStorage.setItem('bestTimes', JSON.stringify(state.bestTimes));
        updateBestTimeDisplay();
        
        if (recordLabel) {
            recordLabel.textContent = 'ðŸŽ‰ NEW RECORD! ðŸŽ‰';
            recordLabel.style.display = 'block';
        }
        
        // Animate best time display
        const bestTimeEl = document.getElementById('best-time');
        bestTimeEl.classList.add('new-record');
        setTimeout(() => bestTimeEl.classList.remove('new-record'), 1500);
    } else {
        if (recordLabel) {
            recordLabel.style.display = 'none';
        }
    }
    
    // Add to leaderboard (if player is signed in)
    if (typeof addToLeaderboard === 'function') {
        addToLeaderboard(currentTime, state.cubeSize, state.moves);
    }
    
    // Check achievements
    checkAchievements(currentTime, state.moves, state.cubeSize, state.impossibleMode);
    
    modal.classList.remove('hidden');
    createConfetti();
}

function updateBestTimeDisplay() {
    const cubeKey = `cube_${state.cubeSize}x${state.cubeSize}${state.impossibleMode ? '_impossible' : ''}`;
    const bestTime = state.bestTimes[cubeKey];
    const bestTimeEl = document.getElementById('best-time');
    
    if (bestTime) {
        bestTimeEl.textContent = formatTime(bestTime);
    } else {
        bestTimeEl.textContent = '--:--.--';
    }
}

function formatTime(ms) {
    const minutes = Math.floor(ms / 60000);
    const seconds = Math.floor((ms % 60000) / 1000);
    const centiseconds = Math.floor((ms % 1000) / 10);
    return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}.${centiseconds.toString().padStart(2, '0')}`;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ACHIEVEMENTS SYSTEM
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function checkAchievements(time, moves, size, impossible) {
    const newlyUnlocked = [];
    
    // Increment total solves
    const totalSolves = (parseInt(localStorage.getItem('totalSolves')) || 0) + 1;
    localStorage.setItem('totalSolves', totalSolves);
    
    ACHIEVEMENTS.forEach(achievement => {
        if (!state.unlockedAchievements.includes(achievement.id)) {
            if (achievement.check(time, moves, size, impossible)) {
                state.unlockedAchievements.push(achievement.id);
                newlyUnlocked.push(achievement);
            }
        }
    });
    
    if (newlyUnlocked.length > 0) {
        localStorage.setItem('achievements', JSON.stringify(state.unlockedAchievements));
        updateAchievementCount();
        
        // Show popups for new achievements (staggered)
        newlyUnlocked.forEach((achievement, index) => {
            setTimeout(() => showAchievementPopup(achievement), index * 500);
        });
    }
}

function showAchievementPopup(achievement) {
    const container = document.getElementById('achievement-popup-container');
    const popup = document.createElement('div');
    popup.className = 'achievement-popup';
    popup.innerHTML = `
        <span class="popup-icon">${achievement.icon}</span>
        <div class="popup-content">
            <span class="popup-title">ACHIEVEMENT UNLOCKED!</span>
            <span class="popup-name">${achievement.name}</span>
            <span class="popup-desc">${achievement.desc}</span>
        </div>
    `;
    container.appendChild(popup);
    
    // Remove after animation
    setTimeout(() => popup.remove(), 4000);
}

function renderAchievementsGrid() {
    const grid = document.getElementById('achievements-grid');
    grid.innerHTML = '';
    
    ACHIEVEMENTS.forEach(achievement => {
        const isUnlocked = state.unlockedAchievements.includes(achievement.id);
        
        const card = document.createElement('div');
        card.className = `achievement-card ${isUnlocked ? 'unlocked' : 'locked'}`;
        card.innerHTML = `
            <span class="achievement-icon">${isUnlocked ? achievement.icon : 'ðŸ”’'}</span>
            <div class="achievement-name">${isUnlocked ? achievement.name : '???'}</div>
            <div class="achievement-desc">${isUnlocked ? achievement.desc : 'Keep playing to unlock!'}</div>
        `;
        grid.appendChild(card);
    });
}

function updateAchievementCount() {
    const count = state.unlockedAchievements.length;
    const total = ACHIEVEMENTS.length;
    document.getElementById('achievement-count').textContent = `${count}/${total}`;
}

// Achievement modal controls
document.getElementById('achievements-btn').addEventListener('click', () => {
    renderAchievementsGrid();
    document.getElementById('achievements-modal').classList.remove('hidden');
});

document.getElementById('close-achievements-btn').addEventListener('click', () => {
    document.getElementById('achievements-modal').classList.add('hidden');
});

document.getElementById('achievements-modal').addEventListener('click', (e) => {
    if (e.target.id === 'achievements-modal') {
        document.getElementById('achievements-modal').classList.add('hidden');
    }
});

// Initialize achievement count on load
updateAchievementCount();

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PLAYER PROFILE & LEADERBOARD SYSTEM
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Player profile state
const playerProfile = {
    name: null,
    solvedIRL: null,
    cheated: null,
    bestTimes: {}, // { "3": timeMs, "4": timeMs, etc }
    totalSolves: 0
};

// Load profile from localStorage
function loadPlayerProfile() {
    const saved = localStorage.getItem('playerProfile');
    if (saved) {
        const data = JSON.parse(saved);
        Object.assign(playerProfile, data);
        updateProfileButton();
        updateProfileView();
    }
}

// Save profile to localStorage
function savePlayerProfile() {
    localStorage.setItem('playerProfile', JSON.stringify(playerProfile));
}

// Update the profile button in header
function updateProfileButton() {
    const btnText = document.getElementById('profile-btn-text');
    if (playerProfile.name) {
        btnText.textContent = playerProfile.name;
    } else {
        btnText.textContent = 'SIGN IN';
    }
}

// Update profile view in modal
function updateProfileView() {
    const signinForm = document.getElementById('signin-form');
    const profileView = document.getElementById('profile-view');
    
    if (playerProfile.name) {
        signinForm.classList.add('hidden');
        profileView.classList.remove('hidden');
        
        document.getElementById('profile-display-name').textContent = playerProfile.name;
        
        // Best time for 3x3
        const bestTime3 = playerProfile.bestTimes['3'];
        document.getElementById('profile-best-time').textContent = bestTime3 ? formatTime(bestTime3) : '--:--';
        
        document.getElementById('profile-total-solves').textContent = playerProfile.totalSolves || 0;
        
        // Solved IRL display
        const solvedMap = { yes: 'âœ… Yes!', no: 'âŒ No', learning: 'ðŸ“š Learning' };
        document.getElementById('profile-solved-irl').textContent = solvedMap[playerProfile.solvedIRL] || '--';
        
        // Cheated display
        const cheatedMap = { never: 'ðŸ˜‡ Never!', maybe: 'ðŸ˜… Maybe...', yes: 'ðŸ˜ˆ Of course!' };
        document.getElementById('profile-cheated').textContent = cheatedMap[playerProfile.cheated] || '--';
    } else {
        signinForm.classList.remove('hidden');
        profileView.classList.add('hidden');
    }
}

// Format time for display
function formatTime(ms) {
    const seconds = Math.floor(ms / 1000) % 60;
    const minutes = Math.floor(ms / 60000);
    const centiseconds = Math.floor((ms % 1000) / 10);
    return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}.${String(centiseconds).padStart(2, '0')}`;
}

// Sign-in form handling
const signinFormState = {
    name: '',
    solved: null,
    cheated: null
};

document.getElementById('player-name-input').addEventListener('input', (e) => {
    signinFormState.name = e.target.value.trim();
    updateSigninSubmitButton();
});

document.querySelectorAll('.signin-option').forEach(btn => {
    btn.addEventListener('click', () => {
        const question = btn.dataset.question;
        const value = btn.dataset.value;
        
        // Deselect other options in same question
        document.querySelectorAll(`.signin-option[data-question="${question}"]`).forEach(b => {
            b.classList.remove('selected');
        });
        
        btn.classList.add('selected');
        signinFormState[question] = value;
        updateSigninSubmitButton();
    });
});

function updateSigninSubmitButton() {
    const btn = document.getElementById('signin-submit-btn');
    const isValid = signinFormState.name.length > 0 && 
                    signinFormState.solved !== null && 
                    signinFormState.cheated !== null;
    btn.disabled = !isValid;
}

document.getElementById('signin-submit-btn').addEventListener('click', () => {
    if (signinFormState.name && signinFormState.solved && signinFormState.cheated) {
        playerProfile.name = signinFormState.name;
        playerProfile.solvedIRL = signinFormState.solved;
        playerProfile.cheated = signinFormState.cheated;
        playerProfile.bestTimes = {};
        playerProfile.totalSolves = 0;
        
        savePlayerProfile();
        updateProfileButton();
        updateProfileView();
    }
});

document.getElementById('signout-btn').addEventListener('click', () => {
    // Clear profile
    playerProfile.name = null;
    playerProfile.solvedIRL = null;
    playerProfile.cheated = null;
    playerProfile.bestTimes = {};
    playerProfile.totalSolves = 0;
    
    // Reset form
    signinFormState.name = '';
    signinFormState.solved = null;
    signinFormState.cheated = null;
    document.getElementById('player-name-input').value = '';
    document.querySelectorAll('.signin-option').forEach(b => b.classList.remove('selected'));
    document.getElementById('signin-submit-btn').disabled = true;
    
    savePlayerProfile();
    updateProfileButton();
    updateProfileView();
});

// Profile modal controls
document.getElementById('profile-btn').addEventListener('click', () => {
    updateProfileView();
    document.getElementById('signin-modal').classList.remove('hidden');
});

document.getElementById('close-signin-btn').addEventListener('click', () => {
    document.getElementById('signin-modal').classList.add('hidden');
});

document.getElementById('signin-modal').addEventListener('click', (e) => {
    if (e.target.id === 'signin-modal') {
        document.getElementById('signin-modal').classList.add('hidden');
    }
});

// Leaderboard system
function getLeaderboard() {
    const saved = localStorage.getItem('leaderboard');
    return saved ? JSON.parse(saved) : [];
}

function saveLeaderboard(leaderboard) {
    localStorage.setItem('leaderboard', JSON.stringify(leaderboard));
}

// Add a solve to leaderboard (called when player solves)
function addToLeaderboard(time, cubeSize, moves) {
    if (!playerProfile.name) return; // Must be signed in
    
    const leaderboard = getLeaderboard();
    
    const entry = {
        name: playerProfile.name,
        time: time,
        cubeSize: cubeSize,
        moves: moves,
        solvedIRL: playerProfile.solvedIRL,
        cheated: playerProfile.cheated,
        date: Date.now()
    };
    
    leaderboard.push(entry);
    
    // Keep only top 100 entries per size to prevent localStorage bloat
    const filtered = leaderboard
        .sort((a, b) => a.time - b.time)
        .slice(0, 500);
    
    saveLeaderboard(filtered);
    
    // Update player's best time
    if (!playerProfile.bestTimes[cubeSize] || time < playerProfile.bestTimes[cubeSize]) {
        playerProfile.bestTimes[cubeSize] = time;
    }
    playerProfile.totalSolves++;
    savePlayerProfile();
}

function renderLeaderboard(sizeFilter = '3') {
    const leaderboard = getLeaderboard();
    const listEl = document.getElementById('leaderboard-list');
    
    // Filter by size
    let filtered = leaderboard;
    if (sizeFilter !== 'all') {
        filtered = leaderboard.filter(e => e.cubeSize == sizeFilter);
    }
    
    // Sort by time
    filtered.sort((a, b) => a.time - b.time);
    
    // Take top 50
    filtered = filtered.slice(0, 50);
    
    if (filtered.length === 0) {
        listEl.innerHTML = `
            <div class="leaderboard-empty">
                <div class="leaderboard-empty-icon">ðŸ†</div>
                <p>No solves recorded yet!</p>
                <p style="font-size: 0.8rem; margin-top: 10px;">Sign in and solve a cube to be the first on the leaderboard!</p>
            </div>
        `;
        return;
    }
    
    listEl.innerHTML = filtered.map((entry, index) => {
        const rank = index + 1;
        let rankClass = '';
        let rankIcon = rank;
        
        if (rank === 1) { rankClass = 'gold'; rankIcon = 'ðŸ¥‡'; }
        else if (rank === 2) { rankClass = 'silver'; rankIcon = 'ðŸ¥ˆ'; }
        else if (rank === 3) { rankClass = 'bronze'; rankIcon = 'ðŸ¥‰'; }
        
        const solvedMap = { yes: 'âœ…', no: 'âŒ', learning: 'ðŸ“š' };
        const cheatedMap = { never: 'ðŸ˜‡', maybe: 'ðŸ˜…', yes: 'ðŸ˜ˆ' };
        
        const isTop3 = rank <= 3 ? 'top-3' : '';
        
        return `
            <div class="leaderboard-entry ${isTop3}">
                <div class="leaderboard-rank ${rankClass}">${rankIcon}</div>
                <div class="leaderboard-player">
                    <div class="leaderboard-player-name">${escapeHtml(entry.name)}</div>
                    <div class="leaderboard-player-info">
                        <span>${entry.cubeSize}Ã—${entry.cubeSize}</span>
                        <span>${entry.moves} moves</span>
                        <span title="Solved IRL?">${solvedMap[entry.solvedIRL] || 'â“'}</span>
                        <span title="Ever cheated?">${cheatedMap[entry.cheated] || 'â“'}</span>
                    </div>
                </div>
                <div class="leaderboard-time">${formatTime(entry.time)}</div>
            </div>
        `;
    }).join('');
}

function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

// Leaderboard modal controls
document.getElementById('leaderboard-btn').addEventListener('click', () => {
    renderLeaderboard('3');
    document.getElementById('leaderboard-modal').classList.remove('hidden');
});

document.getElementById('close-leaderboard-btn').addEventListener('click', () => {
    document.getElementById('leaderboard-modal').classList.add('hidden');
});

document.getElementById('leaderboard-modal').addEventListener('click', (e) => {
    if (e.target.id === 'leaderboard-modal') {
        document.getElementById('leaderboard-modal').classList.add('hidden');
    }
});

// Leaderboard tab switching
document.querySelectorAll('.leaderboard-tab').forEach(tab => {
    tab.addEventListener('click', () => {
        document.querySelectorAll('.leaderboard-tab').forEach(t => t.classList.remove('active'));
        tab.classList.add('active');
        renderLeaderboard(tab.dataset.size);
    });
});

// Load profile on startup
loadPlayerProfile();

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// RACE AI MODE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const race = {
    active: false,
    playerScene: null,
    playerRenderer: null,
    playerCube: null,
    playerCamera: null,
    playerControls: null, // OrbitControls for player view
    aiScene: null,
    aiRenderer: null,
    aiCube: null,
    aiCamera: null,
    aiMoves: [],
    aiMoveIndex: 0,
    aiSolving: false,
    difficulty: 'medium',
    startTime: 0,
    playerFinished: false,
    aiFinished: false,
    playerTime: 0,
    aiTime: 0,
    playerMoveCount: 0,
    aiMoveCount: 0,
    scrambleMoves: [],
    playerMoves: [],
    animationId: null,
    countdownInterval: null,
    // Mouse interaction
    isDragging: false,
    dragStart: null,
    selectedFace: null,
    raycaster: new THREE.Raycaster(),
    mouse: new THREE.Vector2()
};

// AI difficulty settings (delay between moves in ms)
const AI_SPEEDS = {
    easy: 2000,
    medium: 1200,
    hard: 700,
    insane: 350
};

document.getElementById('race-btn').addEventListener('click', () => {
    document.getElementById('race-modal').classList.remove('hidden');
    startRaceCountdown();
});

// Function to close race modal - MUST be global
window.closeRaceModal = function() {
    console.log('closeRaceModal called');
    try {
        endRace();
    } catch(e) {
        console.error('Error in endRace:', e);
    }
    document.getElementById('race-modal').classList.add('hidden');
};

// Keyboard escape to close
document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape' && !document.getElementById('race-modal').classList.contains('hidden')) {
        window.closeRaceModal();
    }
});

// Click outside modal content to close
document.getElementById('race-modal').addEventListener('click', (e) => {
    if (e.target.id === 'race-modal') {
        window.closeRaceModal();
    }
});

document.getElementById('race-again-btn').addEventListener('click', () => {
    startRaceCountdown();
});

// Difficulty buttons
document.querySelectorAll('.ai-diff-btn').forEach(btn => {
    btn.addEventListener('click', () => {
        document.querySelectorAll('.ai-diff-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        race.difficulty = btn.dataset.diff;
    });
});

function startRaceCountdown() {
    // Reset UI
    document.getElementById('race-countdown').style.display = 'block';
    document.getElementById('race-arena').style.display = 'grid'; // Show arena so cubes render
    document.getElementById('race-arena').style.opacity = '0.3'; // But dim it during countdown
    document.getElementById('race-result').classList.remove('show');
    
    race.active = false;
    race.playerFinished = false;
    race.aiFinished = false;
    race.playerTime = 0;
    race.aiTime = 0;
    race.playerMoveCount = 0;
    race.aiMoveCount = 0;
    race.playerMoves = [];
    race.aiMoveIndex = 0;
    
    // Reset displays
    document.getElementById('player-time').textContent = '0.00';
    document.getElementById('ai-time').textContent = '0.00';
    document.getElementById('player-moves').textContent = '0';
    document.getElementById('ai-moves').textContent = '0';
    document.getElementById('player-status').textContent = 'Ready';
    document.getElementById('player-status').className = 'race-player-status';
    document.getElementById('ai-status').textContent = 'Ready';
    document.getElementById('ai-status').className = 'race-player-status';
    document.getElementById('ai-thinking').style.display = 'none';
    
    // Setup cubes after a small delay to ensure containers are visible
    setTimeout(() => {
        setupRaceCubes();
        
        // Scramble both cubes with same moves
        scrambleRaceCubes();
    }, 100);
    
    // Countdown
    let count = 5;
    const countdownEl = document.getElementById('countdown-display');
    countdownEl.textContent = count;
    countdownEl.classList.remove('countdown-go');
    
    // Clear any existing countdown
    if (race.countdownInterval) {
        clearInterval(race.countdownInterval);
    }
    
    race.countdownInterval = setInterval(() => {
        count--;
        if (count > 0) {
            countdownEl.textContent = count;
        } else if (count === 0) {
            countdownEl.textContent = 'GO!';
            countdownEl.classList.add('countdown-go');
        } else {
            clearInterval(race.countdownInterval);
            race.countdownInterval = null;
            startRace();
        }
    }, 1000);
}

function setupRaceCubes() {
    const cubeSize = state.cubeSize || 3;
    
    // Clean up existing
    if (race.playerRenderer) {
        race.playerRenderer.dispose();
        race.playerRenderer = null;
    }
    if (race.aiRenderer) {
        race.aiRenderer.dispose();
        race.aiRenderer = null;
    }
    if (race.animationId) {
        cancelAnimationFrame(race.animationId);
    }
    
    // Setup player cube
    const playerContainer = document.getElementById('player-cube-container');
    playerContainer.innerHTML = '';
    
    // Use fixed dimensions or container dimensions
    const width = playerContainer.clientWidth || 350;
    const height = playerContainer.clientHeight || 280;
    
    race.playerScene = new THREE.Scene();
    race.playerScene.background = new THREE.Color(0x0a0a15);
    
    race.playerCamera = new THREE.PerspectiveCamera(50, width / height, 0.1, 1000);
    race.playerCamera.position.set(cubeSize * 2, cubeSize * 1.5, cubeSize * 2.5);
    race.playerCamera.lookAt(0, 0, 0);
    
    race.playerRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    race.playerRenderer.setSize(width, height);
    race.playerRenderer.setPixelRatio(window.devicePixelRatio);
    playerContainer.appendChild(race.playerRenderer.domElement);
    
    // Add OrbitControls for player to look around
    race.playerControls = new THREE.OrbitControls(race.playerCamera, race.playerRenderer.domElement);
    race.playerControls.enableDamping = true;
    race.playerControls.dampingFactor = 0.1;
    race.playerControls.enableZoom = true;
    race.playerControls.minDistance = cubeSize * 1.5;
    race.playerControls.maxDistance = cubeSize * 5;
    race.playerControls.enablePan = false;
    
    // Add lights to player scene
    const pLight1 = new THREE.DirectionalLight(0xffffff, 1.2);
    pLight1.position.set(5, 10, 5);
    race.playerScene.add(pLight1);
    const pLight2 = new THREE.DirectionalLight(0xffffff, 0.5);
    pLight2.position.set(-5, -5, -5);
    race.playerScene.add(pLight2);
    race.playerScene.add(new THREE.AmbientLight(0x606060, 0.8));
    
    // Setup AI cube
    const aiContainer = document.getElementById('ai-cube-container');
    aiContainer.innerHTML = '';
    
    const aiWidth = aiContainer.clientWidth || 350;
    const aiHeight = aiContainer.clientHeight || 280;
    
    race.aiScene = new THREE.Scene();
    race.aiScene.background = new THREE.Color(0x0a0a15);
    
    race.aiCamera = new THREE.PerspectiveCamera(50, aiWidth / aiHeight, 0.1, 1000);
    race.aiCamera.position.set(cubeSize * 2, cubeSize * 1.5, cubeSize * 2.5);
    race.aiCamera.lookAt(0, 0, 0);
    
    race.aiRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    race.aiRenderer.setSize(aiWidth, aiHeight);
    race.aiRenderer.setPixelRatio(window.devicePixelRatio);
    aiContainer.appendChild(race.aiRenderer.domElement);
    
    // Add lights to AI scene
    const aLight1 = new THREE.DirectionalLight(0xffffff, 1.2);
    aLight1.position.set(5, 10, 5);
    race.aiScene.add(aLight1);
    const aLight2 = new THREE.DirectionalLight(0xffffff, 0.5);
    aLight2.position.set(-5, -5, -5);
    race.aiScene.add(aLight2);
    race.aiScene.add(new THREE.AmbientLight(0x606060, 0.8));
    
    // Create cubes
    race.playerCube = createRaceCube(cubeSize, race.playerScene);
    race.aiCube = createRaceCube(cubeSize, race.aiScene);
    
    // Setup mouse controls for turning
    setupRaceMouseControls();
    
    // Start render loop
    animateRace();
}

function createRaceCube(size, scene) {
    const cube = {
        group: new THREE.Group(),
        rotationGroup: new THREE.Group(),
        cubies: [],
        size: size,
        moveQueue: [],
        isAnimating: false,
        initialState: [] // Store initial positions/quaternions
    };
    
    const gap = 0.08;
    const cubieSize = 1;
    const offset = (size - 1) / 2;
    
    const colors = {
        white: 0xffffff,
        yellow: 0xffcc00,
        red: 0xff3300,
        orange: 0xff8800,
        blue: 0x0066ff,
        green: 0x00cc44
    };
    
    for (let x = 0; x < size; x++) {
        for (let y = 0; y < size; y++) {
            for (let z = 0; z < size; z++) {
                if (x > 0 && x < size - 1 && y > 0 && y < size - 1 && z > 0 && z < size - 1) continue;
                
                const cubie = new THREE.Group();
                
                // Black core
                const coreGeo = new THREE.BoxGeometry(cubieSize * 0.9, cubieSize * 0.9, cubieSize * 0.9);
                const coreMat = new THREE.MeshPhongMaterial({ color: 0x111111 });
                const core = new THREE.Mesh(coreGeo, coreMat);
                cubie.add(core);
                
                // Add stickers
                const stickerSize = cubieSize * 0.85;
                const stickerOffset = cubieSize * 0.46;
                
                if (y === size - 1) addSticker(cubie, colors.white, 0, stickerOffset, 0, 'y', stickerSize);
                if (y === 0) addSticker(cubie, colors.yellow, 0, -stickerOffset, 0, 'y', stickerSize);
                if (z === size - 1) addSticker(cubie, colors.red, 0, 0, stickerOffset, 'z', stickerSize);
                if (z === 0) addSticker(cubie, colors.orange, 0, 0, -stickerOffset, 'z', stickerSize);
                if (x === size - 1) addSticker(cubie, colors.blue, stickerOffset, 0, 0, 'x', stickerSize);
                if (x === 0) addSticker(cubie, colors.green, -stickerOffset, 0, 0, 'x', stickerSize);
                
                cubie.position.set(
                    (x - offset) * (cubieSize + gap),
                    (y - offset) * (cubieSize + gap),
                    (z - offset) * (cubieSize + gap)
                );
                
                cubie.userData = { gridPos: { x, y, z } };
                cube.cubies.push(cubie);
                cube.group.add(cubie);
            }
        }
    }
    
    scene.add(cube.group);
    scene.add(cube.rotationGroup);
    
    // Save initial state for solved checking
    cube.cubies.forEach(cubie => {
        cube.initialState.push({
            position: cubie.position.clone(),
            quaternion: cubie.quaternion.clone()
        });
    });
    
    return cube;
}

function addSticker(cubie, color, x, y, z, axis, size) {
    const geo = new THREE.PlaneGeometry(size, size);
    const mat = new THREE.MeshPhongMaterial({ color: color, side: THREE.DoubleSide });
    const sticker = new THREE.Mesh(geo, mat);
    sticker.position.set(x, y, z);
    
    if (axis === 'x') sticker.rotation.y = Math.PI / 2;
    else if (axis === 'y') sticker.rotation.x = -Math.PI / 2;
    
    cubie.add(sticker);
}

function scrambleRaceCubes() {
    const axes = ['x', 'y', 'z'];
    race.scrambleMoves = [];
    
    const cubeSize = race.playerCube.size;
    
    // Bigger cubes need more scramble moves to be fully scrambled
    // 2x2: 10-15 moves
    // 3x3: 20-25 moves
    // 4x4: 40-50 moves
    // 5x5: 60-75 moves
    // etc.
    let baseLength, extraMoves;
    
    if (cubeSize <= 2) {
        baseLength = 10 + Math.floor(Math.random() * 6);
        extraMoves = Math.floor(Math.random() * 5);
    } else if (cubeSize === 3) {
        baseLength = 20 + Math.floor(Math.random() * 6);
        extraMoves = Math.floor(Math.random() * 5);
    } else {
        // For 4x4 and bigger, scale significantly
        // Each layer can be turned, so more moves needed
        const layerFactor = cubeSize * cubeSize;
        baseLength = Math.floor(layerFactor * 2.5) + Math.floor(Math.random() * layerFactor);
        extraMoves = Math.floor(Math.random() * cubeSize * 3);
    }
    
    const scrambleLength = baseLength + extraMoves;
    
    console.log(`Scramble: ${cubeSize}x${cubeSize} cube with ${scrambleLength} moves`); // Debug
    
    let lastAxis = '';
    let lastLayer = -1;
    
    for (let i = 0; i < scrambleLength; i++) {
        let axis, layer;
        
        // Pick random axis, avoid same axis+layer twice
        do {
            axis = axes[Math.floor(Math.random() * 3)];
            layer = Math.floor(Math.random() * race.playerCube.size);
        } while (axis === lastAxis && layer === lastLayer);
        
        lastAxis = axis;
        lastLayer = layer;
        
        const direction = Math.random() < 0.5 ? 1 : -1;
        race.scrambleMoves.push({ axis, layer, direction });
    }
    
    // Apply to both cubes instantly
    race.scrambleMoves.forEach(move => {
        applyMoveInstant(race.playerCube, move.axis, move.layer, move.direction);
        applyMoveInstant(race.aiCube, move.axis, move.layer, move.direction);
    });
    
    // AI solves - generate solution based on difficulty
    race.aiMoves = generateAISolution();
    race.aiMoveIndex = 0;
    
    console.log('AI will solve in', race.aiMoves.length, 'moves'); // Debug
}

function generateAISolution() {
    // AI doesn't just reverse - it uses a "solving algorithm"
    // This simulates how a real solver would work
    
    const size = race.playerCube.size;
    const axes = ['x', 'y', 'z'];
    let solution = [];
    
    // Base solution length varies by difficulty
    let targetMoves;
    switch (race.difficulty) {
        case 'easy':
            targetMoves = race.scrambleMoves.length + 8 + Math.floor(Math.random() * 10);
            break;
        case 'medium':
            targetMoves = race.scrambleMoves.length + 3 + Math.floor(Math.random() * 6);
            break;
        case 'hard':
            targetMoves = Math.max(race.scrambleMoves.length - 2, race.scrambleMoves.length * 0.85);
            break;
        case 'insane':
            targetMoves = Math.max(race.scrambleMoves.length - 5, race.scrambleMoves.length * 0.7);
            break;
        default:
            targetMoves = race.scrambleMoves.length;
    }
    
    targetMoves = Math.floor(targetMoves);
    
    // Start with reversed scramble
    let baseSolution = [...race.scrambleMoves].reverse().map(m => ({
        axis: m.axis,
        layer: m.layer,
        direction: -m.direction
    }));
    
    // Optimize by canceling opposite moves
    let optimized = [];
    for (const move of baseSolution) {
        const last = optimized[optimized.length - 1];
        
        if (last && last.axis === move.axis && last.layer === move.layer) {
            const combined = last.direction + move.direction;
            if (combined === 0) {
                optimized.pop();
            } else {
                last.direction = combined > 0 ? 1 : -1;
            }
        } else {
            optimized.push({ ...move });
        }
    }
    
    // For easy/medium, add some extra moves to make it longer
    if (race.difficulty === 'easy' || race.difficulty === 'medium') {
        const extraNeeded = Math.max(0, targetMoves - optimized.length);
        
        for (let i = 0; i < extraNeeded; i++) {
            const idx = Math.floor(Math.random() * (optimized.length + 1));
            const axis = axes[Math.floor(Math.random() * 3)];
            const layer = Math.floor(Math.random() * size);
            
            // Insert a move pair that cancels out (wastes time)
            optimized.splice(idx, 0,
                { axis, layer, direction: 1 },
                { axis, layer, direction: -1 }
            );
            i++; // Count both moves
        }
    }
    
    return optimized;
}

function applyMoveInstant(cube, axis, layer, direction) {
    const angle = (Math.PI / 2) * direction;
    const cubies = getCubiesInLayerRace(cube, axis, layer);
    
    const rotationAxis = new THREE.Vector3(
        axis === 'x' ? 1 : 0,
        axis === 'y' ? 1 : 0,
        axis === 'z' ? 1 : 0
    );
    
    const gridSize = 1.08;
    const isEven = cube.size % 2 === 0;
    
    cubies.forEach(cubie => {
        // Rotate position around axis
        cubie.position.applyAxisAngle(rotationAxis, angle);
        
        // Rotate the cubie itself
        const quaternion = new THREE.Quaternion().setFromAxisAngle(rotationAxis, angle);
        cubie.quaternion.premultiply(quaternion);
        
        // Snap position to grid - handle even vs odd cubes
        if (isEven) {
            // Even cubes: positions are at Â±0.5, Â±1.5, Â±2.5, etc. (in grid units)
            cubie.position.x = (Math.round(cubie.position.x / gridSize - 0.5) + 0.5) * gridSize;
            cubie.position.y = (Math.round(cubie.position.y / gridSize - 0.5) + 0.5) * gridSize;
            cubie.position.z = (Math.round(cubie.position.z / gridSize - 0.5) + 0.5) * gridSize;
        } else {
            // Odd cubes: positions are at 0, Â±1, Â±2, etc. (in grid units)
            cubie.position.x = Math.round(cubie.position.x / gridSize) * gridSize;
            cubie.position.y = Math.round(cubie.position.y / gridSize) * gridSize;
            cubie.position.z = Math.round(cubie.position.z / gridSize) * gridSize;
        }
    });
}

function getCubiesInLayerRace(cube, axis, layer) {
    const gridSize = 1.08;
    const threshold = gridSize * 0.45;
    const offset = (cube.size - 1) / 2;
    const targetPos = (layer - offset) * gridSize;
    
    return cube.cubies.filter(cubie => {
        const pos = cubie.position[axis];
        return Math.abs(pos - targetPos) < threshold;
    });
}

function startRace() {
    document.getElementById('race-countdown').style.display = 'none';
    document.getElementById('race-arena').style.display = 'grid';
    document.getElementById('race-arena').style.opacity = '1'; // Full opacity now
    
    race.active = true;
    race.startTime = Date.now();
    race.aiSolving = true;
    
    document.getElementById('player-status').textContent = 'Solving...';
    document.getElementById('player-status').className = 'race-player-status solving';
    document.getElementById('ai-status').textContent = 'Solving...';
    document.getElementById('ai-status').className = 'race-player-status solving';
    document.getElementById('ai-thinking').style.display = 'flex';
    
    // Start AI solving
    solveAI();
    
    // Update timer
    updateRaceTimer();
}

function updateRaceTimer() {
    if (!race.active) return;
    
    const elapsed = (Date.now() - race.startTime) / 1000;
    
    if (!race.playerFinished) {
        document.getElementById('player-time').textContent = elapsed.toFixed(2);
    }
    if (!race.aiFinished) {
        document.getElementById('ai-time').textContent = elapsed.toFixed(2);
    }
    
    requestAnimationFrame(updateRaceTimer);
}

async function solveAI() {
    if (!race.active || race.aiFinished) return;
    
    const speed = AI_SPEEDS[race.difficulty];
    
    // Small initial delay to let player see the scrambled state
    await new Promise(r => setTimeout(r, 500));
    
    while (race.aiMoveIndex < race.aiMoves.length && race.active && !race.aiFinished && !race.playerFinished) {
        const move = race.aiMoves[race.aiMoveIndex];
        
        // Animation takes 40% of the time, pause takes 60%
        await animateRaceMove(race.aiCube, move.axis, move.layer, move.direction, speed * 0.4);
        race.aiMoveCount++;
        document.getElementById('ai-moves').textContent = race.aiMoveCount;
        
        race.aiMoveIndex++;
        
        // Wait between moves
        await new Promise(r => setTimeout(r, speed * 0.6));
        
        // Check if player already won
        if (race.playerFinished) return;
    }
    
    // AI finished - only show result if player hasn't won yet
    if (race.active && !race.playerFinished && !race.aiFinished) {
        race.aiFinished = true;
        race.aiTime = (Date.now() - race.startTime) / 1000;
        document.getElementById('ai-status').textContent = 'FINISHED!';
        document.getElementById('ai-status').className = 'race-player-status finished';
        document.getElementById('ai-thinking').style.display = 'none';
        document.getElementById('ai-time').textContent = race.aiTime.toFixed(2);
        
        // AI wins
        showRaceResult(false);
    }
}

function animateRaceMove(cube, axis, layer, direction, duration) {
    return new Promise(resolve => {
        const angle = (Math.PI / 2) * direction;
        const cubies = getCubiesInLayerRace(cube, axis, layer);
        
        if (cubies.length === 0) {
            resolve();
            return;
        }
        
        // Store original positions and quaternions
        const originalData = cubies.map(cubie => ({
            cubie,
            position: cubie.position.clone(),
            quaternion: cubie.quaternion.clone()
        }));
        
        const rotationAxis = new THREE.Vector3(
            axis === 'x' ? 1 : 0,
            axis === 'y' ? 1 : 0,
            axis === 'z' ? 1 : 0
        );
        
        const gridSize = 1.08;
        const isEven = cube.size % 2 === 0;
        const startTime = Date.now();
        
        function animate() {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(elapsed / duration, 1);
            const eased = 1 - Math.pow(1 - progress, 3);
            const currentAngle = angle * eased;
            
            // Apply rotation to each cubie
            originalData.forEach(({ cubie, position, quaternion }) => {
                // Rotate position
                cubie.position.copy(position).applyAxisAngle(rotationAxis, currentAngle);
                
                // Rotate orientation
                const rotQuat = new THREE.Quaternion().setFromAxisAngle(rotationAxis, currentAngle);
                cubie.quaternion.copy(rotQuat).multiply(quaternion);
            });
            
            if (progress < 1) {
                requestAnimationFrame(animate);
            } else {
                // Snap to final positions - handle even vs odd cubes
                cubies.forEach(cubie => {
                    if (isEven) {
                        cubie.position.x = (Math.round(cubie.position.x / gridSize - 0.5) + 0.5) * gridSize;
                        cubie.position.y = (Math.round(cubie.position.y / gridSize - 0.5) + 0.5) * gridSize;
                        cubie.position.z = (Math.round(cubie.position.z / gridSize - 0.5) + 0.5) * gridSize;
                    } else {
                        cubie.position.x = Math.round(cubie.position.x / gridSize) * gridSize;
                        cubie.position.y = Math.round(cubie.position.y / gridSize) * gridSize;
                        cubie.position.z = Math.round(cubie.position.z / gridSize) * gridSize;
                    }
                });
                resolve();
            }
        }
        animate();
    });
}

// Player can solve by pressing keys during race
document.addEventListener('keydown', (e) => {
    if (!race.active || race.playerFinished || !race.playerCube) return;
    
    const key = e.key.toUpperCase();
    const moves = {
        'U': { axis: 'y', layer: race.playerCube.size - 1 },
        'D': { axis: 'y', layer: 0 },
        'R': { axis: 'x', layer: race.playerCube.size - 1 },
        'L': { axis: 'x', layer: 0 },
        'F': { axis: 'z', layer: race.playerCube.size - 1 },
        'B': { axis: 'z', layer: 0 }
    };
    
    if (moves[key] && !race.playerCube.isAnimating) {
        e.preventDefault();
        const direction = e.shiftKey ? -1 : 1;
        executePlayerMove(moves[key].axis, moves[key].layer, direction);
    }
});

function executePlayerMove(axis, layer, direction) {
    if (!race.active || race.playerFinished || !race.playerCube || race.playerCube.isAnimating) return;
    
    race.playerCube.isAnimating = true;
    const move = { axis, layer, direction };
    race.playerMoves.push(move);
    
    animateRaceMove(race.playerCube, axis, layer, direction, 120)
        .then(() => {
            race.playerCube.isAnimating = false;
            race.playerMoveCount++;
            document.getElementById('player-moves').textContent = race.playerMoveCount;
            
            if (race.playerMoveCount >= race.scrambleMoves.length) {
                if (isRaceCubeSolved(race.playerCube)) {
                    playerWins();
                }
            }
        });
}

// Mouse controls for race cube
function setupRaceMouseControls() {
    const container = document.getElementById('player-cube-container');
    if (!container) return;
    
    let mouseDownPos = null;
    let selectedCubie = null;
    let selectedFaceNormal = null;
    
    container.addEventListener('mousedown', (e) => {
        if (!race.active || race.playerFinished || !race.playerCube || race.playerCube.isAnimating) return;
        if (e.button !== 0) return; // Left click only
        
        const rect = container.getBoundingClientRect();
        race.mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
        race.mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
        
        race.raycaster.setFromCamera(race.mouse, race.playerCamera);
        const intersects = race.raycaster.intersectObjects(race.playerCube.cubies, true);
        
        if (intersects.length > 0) {
            // Disable orbit controls while dragging cube face
            if (race.playerControls) race.playerControls.enabled = false;
            
            mouseDownPos = { x: e.clientX, y: e.clientY };
            
            // Find the cubie (parent group)
            let cubie = intersects[0].object;
            while (cubie.parent && !race.playerCube.cubies.includes(cubie)) {
                cubie = cubie.parent;
            }
            selectedCubie = cubie;
            
            // Get face normal in world space
            const faceNormal = intersects[0].face.normal.clone();
            faceNormal.transformDirection(intersects[0].object.matrixWorld);
            selectedFaceNormal = faceNormal;
        }
    });
    
    container.addEventListener('mousemove', (e) => {
        if (!mouseDownPos || !selectedCubie) return;
        
        const dx = e.clientX - mouseDownPos.x;
        const dy = e.clientY - mouseDownPos.y;
        const threshold = 30;
        
        if (Math.abs(dx) > threshold || Math.abs(dy) > threshold) {
            // Determine rotation based on drag direction and face clicked
            const move = determineMove(selectedCubie, selectedFaceNormal, dx, dy);
            
            if (move) {
                executePlayerMove(move.axis, move.layer, move.direction);
            }
            
            // Reset
            mouseDownPos = null;
            selectedCubie = null;
            selectedFaceNormal = null;
            if (race.playerControls) race.playerControls.enabled = true;
        }
    });
    
    container.addEventListener('mouseup', () => {
        mouseDownPos = null;
        selectedCubie = null;
        selectedFaceNormal = null;
        if (race.playerControls) race.playerControls.enabled = true;
    });
    
    container.addEventListener('mouseleave', () => {
        mouseDownPos = null;
        selectedCubie = null;
        selectedFaceNormal = null;
        if (race.playerControls) race.playerControls.enabled = true;
    });
}

function determineMove(cubie, faceNormal, dx, dy) {
    if (!cubie || !race.playerCube) return null;
    
    const size = race.playerCube.size;
    const gridSize = 1.08;
    const pos = cubie.position;
    
    // Determine which face was clicked based on normal
    const threshold = 0.5;
    let clickedFace = '';
    
    if (Math.abs(faceNormal.y - 1) < threshold) clickedFace = 'top';
    else if (Math.abs(faceNormal.y + 1) < threshold) clickedFace = 'bottom';
    else if (Math.abs(faceNormal.z - 1) < threshold) clickedFace = 'front';
    else if (Math.abs(faceNormal.z + 1) < threshold) clickedFace = 'back';
    else if (Math.abs(faceNormal.x - 1) < threshold) clickedFace = 'right';
    else if (Math.abs(faceNormal.x + 1) < threshold) clickedFace = 'left';
    
    // Get layer from cubie position
    const offset = (size - 1) / 2;
    const layerX = Math.round(pos.x / gridSize + offset);
    const layerY = Math.round(pos.y / gridSize + offset);
    const layerZ = Math.round(pos.z / gridSize + offset);
    
    // Determine move based on face and drag direction
    const horizontal = Math.abs(dx) > Math.abs(dy);
    const direction = horizontal ? (dx > 0 ? 1 : -1) : (dy > 0 ? -1 : 1);
    
    switch (clickedFace) {
        case 'top':
        case 'bottom':
            if (horizontal) {
                return { axis: 'z', layer: layerZ, direction: clickedFace === 'top' ? direction : -direction };
            } else {
                return { axis: 'x', layer: layerX, direction: clickedFace === 'top' ? direction : -direction };
            }
        case 'front':
        case 'back':
            if (horizontal) {
                return { axis: 'y', layer: layerY, direction: clickedFace === 'front' ? -direction : direction };
            } else {
                return { axis: 'x', layer: layerX, direction: clickedFace === 'front' ? direction : -direction };
            }
        case 'right':
        case 'left':
            if (horizontal) {
                return { axis: 'y', layer: layerY, direction: clickedFace === 'right' ? -direction : direction };
            } else {
                return { axis: 'z', layer: layerZ, direction: clickedFace === 'right' ? -direction : direction };
            }
    }
    
    return null;
}

function isRaceCubeSolved(cube) {
    // Must have made at least as many moves as scramble to prevent early detection
    if (race.playerMoveCount < race.scrambleMoves.length) {
        return false;
    }
    
    // Compare current state with initial state
    const tolerance = 0.15;
    
    for (let i = 0; i < cube.cubies.length; i++) {
        const cubie = cube.cubies[i];
        const initial = cube.initialState[i];
        
        // Check position matches
        if (Math.abs(cubie.position.x - initial.position.x) > tolerance) return false;
        if (Math.abs(cubie.position.y - initial.position.y) > tolerance) return false;
        if (Math.abs(cubie.position.z - initial.position.z) > tolerance) return false;
        
        // Check quaternion matches (or is equivalent)
        // Two quaternions q and -q represent the same rotation
        const q1 = cubie.quaternion;
        const q2 = initial.quaternion;
        
        const dot = Math.abs(q1.x * q2.x + q1.y * q2.y + q1.z * q2.z + q1.w * q2.w);
        if (dot < 0.98) return false;
    }
    
    return true;
}

function playerWins() {
    race.playerFinished = true;
    race.playerTime = (Date.now() - race.startTime) / 1000;
    document.getElementById('player-status').textContent = 'FINISHED!';
    document.getElementById('player-status').className = 'race-player-status finished';
    
    if (!race.aiFinished) {
        showRaceResult(true);
    }
}

function showRaceResult(playerWon) {
    race.active = false;
    
    const resultEl = document.getElementById('race-result');
    const titleEl = document.getElementById('result-title');
    const detailsEl = document.getElementById('result-details');
    
    if (playerWon) {
        titleEl.textContent = 'ðŸŽ‰ YOU WIN!';
        titleEl.className = 'race-result-title win';
        detailsEl.textContent = `You solved it in ${race.playerTime.toFixed(2)}s with ${race.playerMoveCount} moves!`;
        
        // Achievement check
        if (race.difficulty === 'hard' || race.difficulty === 'insane') {
            const achId = 'race_winner';
            if (!state.unlockedAchievements.includes(achId)) {
                state.unlockedAchievements.push(achId);
                localStorage.setItem('achievements', JSON.stringify(state.unlockedAchievements));
                showAchievementPopup({ name: 'Speed Demon', desc: 'Beat the AI on Hard or Insane!', icon: 'ðŸ†' });
            }
        }
    } else {
        titleEl.textContent = 'ðŸ˜” AI WINS';
        titleEl.className = 'race-result-title lose';
        detailsEl.textContent = `AI solved it in ${race.aiTime.toFixed(2)}s with ${race.aiMoveCount} moves. Try again!`;
    }
    
    resultEl.classList.add('show');
}

function animateRace() {
    if (race.playerControls) {
        race.playerControls.update();
    }
    if (race.playerRenderer && race.playerScene && race.playerCamera) {
        race.playerRenderer.render(race.playerScene, race.playerCamera);
    }
    if (race.aiRenderer && race.aiScene && race.aiCamera) {
        race.aiRenderer.render(race.aiScene, race.aiCamera);
    }
    race.animationId = requestAnimationFrame(animateRace);
}

function endRace() {
    race.active = false;
    race.aiSolving = false;
    
    // Clear countdown interval if running
    if (race.countdownInterval) {
        clearInterval(race.countdownInterval);
        race.countdownInterval = null;
    }
    
    if (race.animationId) {
        cancelAnimationFrame(race.animationId);
        race.animationId = null;
    }
    
    if (race.playerControls) {
        race.playerControls.dispose();
        race.playerControls = null;
    }
    
    if (race.playerRenderer) {
        race.playerRenderer.dispose();
        race.playerRenderer = null;
    }
    if (race.aiRenderer) {
        race.aiRenderer.dispose();
        race.aiRenderer = null;
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// BAN SCREEN (Easter Egg)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

let isForeverBanned = false;
let banGlitchTimer = null;

function showBanScreen() {
    const banScreen = document.getElementById('ban-screen');
    const banTimer = document.getElementById('ban-timer');
    const banAppealInput = document.getElementById('ban-appeal-input');
    const banSecretCode = document.getElementById('ban-secret-code');
    
    banScreen.classList.remove('hidden');
    banAppealInput.value = '';
    banAppealInput.classList.remove('success');
    banAppealInput.placeholder = 'Type "sorry" to appeal...';
    banAppealInput.disabled = false;
    
    if (banSecretCode) {
        banSecretCode.value = '';
        banSecretCode.disabled = false;
    }
    
    // Clear previous timer
    if (banGlitchTimer) clearInterval(banGlitchTimer);
    
    // Infinite glitching timer
    banGlitchTimer = setInterval(() => {
        if (banScreen.classList.contains('hidden') || isForeverBanned) {
            clearInterval(banGlitchTimer);
            return;
        }
        
        if (Math.random() < 0.3) {
            const symbols = ['âˆž', '???', 'ERROR', 'â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ', 'NEVER', '99999', 'â˜ ï¸'];
            banTimer.textContent = symbols[Math.floor(Math.random() * symbols.length)];
        } else {
            banTimer.textContent = 'âˆž';
        }
    }, 500);
    
    // Listen for "sorry" in the appeal input
    banAppealInput.oninput = (e) => {
        if (isForeverBanned) return;
        
        const value = e.target.value.toLowerCase();
        
        if (value === 'sorry') {
            clearInterval(banGlitchTimer);
            banAppealInput.classList.add('success');
            banAppealInput.disabled = true;
            banTimer.textContent = 'FORGIVEN';
            banTimer.style.color = '#00ff88';
            
            setTimeout(() => {
                banScreen.classList.add('hidden');
                document.getElementById('secret-code').disabled = false;
                document.getElementById('secret-code').value = '';
                banAppealInput.disabled = false;
                banAppealInput.value = '';
                banAppealInput.classList.remove('success');
                banTimer.style.color = '#ff0000';
                
                const popup = document.createElement('div');
                popup.className = 'achievement-popup';
                popup.innerHTML = `
                    <span class="popup-icon">ðŸ™</span>
                    <div class="popup-content">
                        <span class="popup-title">UNBANNED!</span>
                        <span class="popup-name">Apology Accepted</span>
                        <span class="popup-desc">Don't enter that code again! ðŸ˜¤</span>
                    </div>
                `;
                document.getElementById('achievement-popup-container').appendChild(popup);
                setTimeout(() => popup.remove(), 4000);
            }, 1500);
        }
    };
    
    // Listen for 6-7 in the hidden input on ban screen
    if (banSecretCode) {
        banSecretCode.oninput = (e) => {
            const value = e.target.value.toLowerCase();
            if (value === '6-7' && !isForeverBanned) {
                showForeverBan();
            }
        };
    }
}

function showForeverBan() {
    isForeverBanned = true;
    localStorage.setItem('foreverBanned', 'true');
    
    if (banGlitchTimer) clearInterval(banGlitchTimer);
    
    const banScreen = document.getElementById('ban-screen');
    const banTimer = document.getElementById('ban-timer');
    const banAppealInput = document.getElementById('ban-appeal-input');
    const banSecretCode = document.getElementById('ban-secret-code');
    const banTitle = document.getElementById('ban-title');
    const banIcon = document.getElementById('ban-icon');
    const banReasonText = document.getElementById('ban-reason-text');
    const banMessage = document.getElementById('ban-message');
    
    // Make sure ban screen is visible
    banScreen.classList.remove('hidden');
    
    // Update the ban screen to show it's forever
    if (banIcon) {
        banIcon.textContent = 'ðŸ’€';
    }
    
    if (banTitle) {
        banTitle.textContent = 'ðŸ’€ FOREVER BANNED ðŸ’€';
        banTitle.style.color = '#ff0000';
        banTitle.style.textShadow = '0 0 20px #ff0000, 0 0 40px #ff0000, 0 0 60px #ff0000';
    }
    
    if (banReasonText) {
        banReasonText.innerHTML = 'You entered 6-7 WHILE ALREADY BANNED';
    }
    
    if (banMessage) {
        banMessage.innerHTML = `
            <span style="color:#ff4444; font-size: 1.2em;">âš ï¸ CRITICAL ERROR âš ï¸</span><br><br>
            You absolute madlad. You entered the forbidden code<br>
            WHILE ALREADY BEING BANNED.<br><br>
            <span style="color:#ff0000; font-weight: bold;">THERE IS NO ESCAPE.</span><br>
            <span style="color:#ff0000;">THIS BAN IS TRULY PERMANENT.</span><br>
            <span style="color:#666; font-size: 0.8em;">(You did this to yourself)</span>
        `;
    }
    
    // Disable ALL inputs
    if (banAppealInput) {
        banAppealInput.value = 'NO ESCAPE';
        banAppealInput.disabled = true;
        banAppealInput.style.background = '#330000';
        banAppealInput.style.color = '#ff0000';
        banAppealInput.style.cursor = 'not-allowed';
    }
    
    if (banSecretCode) {
        banSecretCode.style.display = 'none';
    }
    
    // Scary timer animation
    let foreverCount = 0;
    setInterval(() => {
        const scaryMessages = [
            'ðŸ’€ FOREVER ðŸ’€',
            'âˆž ETERNITY âˆž',
            'NO ESCAPE',
            'â˜ ï¸â˜ ï¸â˜ ï¸â˜ ï¸â˜ ï¸',
            'PERMANENT',
            'YOU DID THIS',
            'âˆžâˆžâˆžâˆžâˆžâˆžâˆž',
            'GOODBYE',
            'NEVER AGAIN',
            'â›” BANNED â›”',
            'HAHAHAHA',
            'RIP',
            'ðŸ’€ðŸ’€ðŸ’€ðŸ’€ðŸ’€'
        ];
        banTimer.textContent = scaryMessages[foreverCount % scaryMessages.length];
        banTimer.style.color = Math.random() > 0.5 ? '#ff0000' : '#ff4444';
        foreverCount++;
    }, 300);
    
    // Add dramatic screen shake
    banScreen.style.animation = 'foreverShake 0.15s infinite';
    
    // Flash the screen red
    document.body.style.animation = 'foreverFlash 2s ease-out';
    
    // Show popup
    const popup = document.createElement('div');
    popup.className = 'achievement-popup';
    popup.innerHTML = `
        <span class="popup-icon">ðŸ’€</span>
        <div class="popup-content">
            <span class="popup-title" style="color:#ff0000">FOREVER BANNED</span>
            <span class="popup-name">No Turning Back</span>
            <span class="popup-desc">You absolute madlad...</span>
        </div>
    `;
    document.getElementById('achievement-popup-container').appendChild(popup);
    setTimeout(() => popup.remove(), 5000);
    
    console.log('ðŸ’€ FOREVER BANNED - There is no escape now');
}

// Check if forever banned on page load
if (localStorage.getItem('foreverBanned') === 'true') {
    isForeverBanned = true;
    setTimeout(() => {
        showForeverBan();
    }, 500);
}


function setBestTime() {
    const time = parseInt(document.getElementById('sue-best-time').value);
    const key = `best_${state.cubeSize}_normal`;
    localStorage.setItem(key, time.toString());
    state.bestTimes[key] = time;
    updateBestTimeDisplay();
    alert(`âœ… Best time set to ${(time/1000).toFixed(2)}s for ${state.cubeSize}x${state.cubeSize}`);
}

function addSolves() {
    const solves = parseInt(document.getElementById('sue-solves').value);
    const current = parseInt(localStorage.getItem('totalSolves')) || 0;
    localStorage.setItem('totalSolves', (current + solves).toString());
    alert(`âœ… Added ${solves} solves. Total: ${current + solves}`);
}

function unlockAllThemes() {
    THEMES.forEach(theme => {
        if (!state.unlockedThemes.includes(theme.id)) {
            state.unlockedThemes.push(theme.id);
        }
    });
    localStorage.setItem('unlockedThemes', JSON.stringify(state.unlockedThemes));
    populateThemesGrid();
    alert('âœ… All themes unlocked!');
}


function unlockAllAchievements() {
    ACHIEVEMENTS.forEach(ach => {
        if (!state.unlockedAchievements.includes(ach.id)) {
            state.unlockedAchievements.push(ach.id);
        }
    });
    localStorage.setItem('achievements', JSON.stringify(state.unlockedAchievements));
    displayAchievements();
    updateAchievementCount();
    alert(`âœ… All ${ACHIEVEMENTS.length} achievements unlocked!`);
}

function resetAllData() {
    if (confirm('âš ï¸ This will reset ALL game data. Are you sure?')) {
        localStorage.clear();
        alert('âœ… All data cleared. Reloading...');
        location.reload();
    }
}

function autoSolveCube() {
    if (state.currentPuzzle && state.currentPuzzle.animatedSolve) {
        state.currentPuzzle.animatedSolve();
        document.getElementById('sue-modal').classList.add('hidden');
    }
}

function createConfetti() {
    const container = document.querySelector('.confetti');
    container.innerHTML = '';
    
    const colors = ['#00f5ff', '#ff00aa', '#f0ff00', '#00ff88'];
    
    for (let i = 0; i < 50; i++) {
        const confetti = document.createElement('div');
        confetti.style.cssText = `
            position: absolute;
            width: ${Math.random() * 10 + 5}px;
            height: ${Math.random() * 10 + 5}px;
            background: ${colors[Math.floor(Math.random() * colors.length)]};
            left: ${Math.random() * 100}%;
            top: -20px;
            opacity: ${Math.random() * 0.5 + 0.5};
            animation: confettiFall ${Math.random() * 2 + 2}s linear forwards;
            animation-delay: ${Math.random() * 0.5}s;
        `;
        container.appendChild(confetti);
    }
    
    if (!document.getElementById('confetti-style')) {
        const style = document.createElement('style');
        style.id = 'confetti-style';
        style.textContent = `
            @keyframes confettiFall {
                to {
                    top: 100%;
                    transform: rotate(720deg) translateX(50px);
                    opacity: 0;
                }
            }
        `;
        document.head.appendChild(style);
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// THEME SYSTEM
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

let currentTheme = 'cyber';
let unlockedThemes = JSON.parse(localStorage.getItem('unlockedThemes')) || ['cyber'];
let pendingUnlock = null;

function applyTheme(themeId) {
    const theme = THEMES.find(t => t.id === themeId);
    if (!theme) return;
    
    document.documentElement.setAttribute('data-theme', themeId);
    currentTheme = themeId;
    localStorage.setItem('currentTheme', themeId);
    
    // Update scene background
    if (state.scene) {
        state.scene.background = new THREE.Color(theme.bgColor);
    }
    
    renderThemesGrid();
}

function renderThemesGrid() {
    const grid = document.getElementById('themes-grid');
    grid.innerHTML = '';
    
    THEMES.forEach(theme => {
        const isUnlocked = unlockedThemes.includes(theme.id);
        const isActive = currentTheme === theme.id;
        const requiresAds = theme.requiresAds === true;
        
        const card = document.createElement('div');
        card.className = `theme-card ${isActive ? 'active' : ''} ${!isUnlocked ? 'locked' : ''}`;
        
        let unlockHint = '';
        if (!isUnlocked) {
            if (requiresAds) {
                unlockHint = '<div class="unlock-hint">ðŸ’¨ Watch 3 ads to unlock</div>';
            } else {
                unlockHint = '<div class="unlock-hint">ðŸ“º Watch ad to unlock</div>';
            }
        }
        
        card.innerHTML = `
            <div class="theme-preview" style="background: ${theme.bgColor}">
                ${requiresAds && !isUnlocked ? '<span class="retro-theme-badge">RETRO</span>' : ''}
                <div class="preview-cube">
                    ${theme.colors.slice(0, 9).map(c => `<span style="background: ${c}"></span>`).join('')}
                </div>
            </div>
            <div class="theme-info">
                <div class="theme-name" style="color: ${theme.colors[0]}">${theme.name}</div>
                <div class="theme-status">${isActive ? 'âœ“ Active' : (isUnlocked ? 'Unlocked' : '')}</div>
                ${unlockHint}
            </div>
        `;
        
        card.addEventListener('click', () => {
            if (isUnlocked) {
                applyTheme(theme.id);
            } else if (requiresAds) {
                pendingUnlock = theme.id;
                pendingUnlockName = theme.name;
            } else {
                pendingUnlock = theme.id;
                showAdModal(theme.name);
            }
        });
        
        grid.appendChild(card);
    });
}

function showAdModal(themeName) {
    const modal = document.getElementById('ad-modal');
    const progressBar = document.getElementById('ad-progress-bar');
    const timerDisplay = document.getElementById('ad-timer');
    const skipBtn = document.getElementById('skip-ad-btn');
    const themeNameSpan = document.getElementById('unlocking-theme-name');
    
    themeNameSpan.textContent = themeName;
    modal.classList.remove('hidden');
    progressBar.style.width = '0%';
    timerDisplay.textContent = '5';
    skipBtn.disabled = true;
    skipBtn.innerHTML = 'Skip in <span id="skip-countdown">5</span>s';
    
    let timeLeft = 5;
    let progress = 0;
    
    const interval = setInterval(() => {
        progress += 2;
        progressBar.style.width = progress + '%';
        
        if (progress >= 20 * (6 - timeLeft)) {
            timeLeft--;
            timerDisplay.textContent = timeLeft;
            const countdown = document.getElementById('skip-countdown');
            if (countdown) countdown.textContent = timeLeft;
        }
        
        if (timeLeft <= 0) {
            clearInterval(interval);
            skipBtn.disabled = false;
            skipBtn.textContent = 'ðŸŽ‰ CLAIM THEME!';
        }
    }, 100);
}


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ANIMATION LOOP
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function updateImpossibleColors() {
    if (!state.impossibleMode || !state.currentPuzzle) return;
    
    const cameraDir = new THREE.Vector3();
    state.camera.getWorldDirection(cameraDir);
    
    // Get camera position for additional angle variation
    const cameraPos = state.camera.position.clone().normalize();
    
    // Get cube size for proper scaling on larger cubes
    const cubeSize = state.currentPuzzle.size || 3;
    const cubeScale = state.currentPuzzle.cubeSize || 1;
    // Calculate the actual cube extent for normalization
    const cubeExtent = ((cubeSize - 1) / 2) * cubeScale;
    
    state.currentPuzzle.cubies.forEach((cubie, cubieIndex) => {
        cubie.traverse(child => {
            if (child.userData && child.userData.isSticker) {
                const colorName = child.userData.colorName;
                const colorArray = IMPOSSIBLE_COLORS[colorName];
                
                if (colorArray) {
                    // Get the world normal of the sticker
                    const worldNormal = child.userData.faceNormal.clone();
                    
                    // Apply cubie's rotation to the normal
                    const cubieQuat = new THREE.Quaternion();
                    cubie.getWorldQuaternion(cubieQuat);
                    worldNormal.applyQuaternion(cubieQuat);
                    
                    // Calculate multiple angle-based factors (no time component!)
                    const dotDir = worldNormal.dot(cameraDir);
                    const dotPos = worldNormal.dot(cameraPos);
                    
                    // Get sticker world position for per-sticker variation
                    const worldPos = new THREE.Vector3();
                    child.getWorldPosition(worldPos);
                    
                    // Normalize position by cube extent so bigger cubes have same variation
                    const normX = cubeExtent > 0 ? worldPos.x / cubeExtent : worldPos.x;
                    const normY = cubeExtent > 0 ? worldPos.y / cubeExtent : worldPos.y;
                    const normZ = cubeExtent > 0 ? worldPos.z / cubeExtent : worldPos.z;
                    
                    // Create chaotic index using ONLY angle-based factors:
                    // - Camera direction dot product
                    // - Camera position dot product  
                    // - Normalized sticker position (each sticker behaves differently)
                    const positionOffset = (normX * 1.3 + normY * 1.7 + normZ * 2.1) * 0.5;
                    const angleFactor = (dotDir * 2.5 + dotPos * 1.5); // Sensitive to angle changes
                    
                    // Combine factors for color cycling - stable when camera stops
                    const chaos = (angleFactor + positionOffset) * Math.PI * 1.2;
                    
                    // Determine which two colors to blend between
                    const numColors = colorArray.length;
                    const rawIndex = ((chaos % (Math.PI * 2)) + Math.PI * 2) % (Math.PI * 2);
                    const normalizedIndex = (rawIndex / (Math.PI * 2)) * numColors;
                    
                    const index1 = Math.floor(normalizedIndex) % numColors;
                    const index2 = (index1 + 1) % numColors;
                    const blendFactor = normalizedIndex - Math.floor(normalizedIndex);
                    
                    // Interpolate between adjacent colors in the array
                    const color1 = new THREE.Color(colorArray[index1]);
                    const color2 = new THREE.Color(colorArray[index2]);
                    const finalColor = color1.clone().lerp(color2, blendFactor);
                    
                    child.material.color.copy(finalColor);
                }
            }
        });
    });
}

function animate() {
    requestAnimationFrame(animate);
    state.controls.update();
    updateImpossibleColors();
    state.renderer.render(state.scene, state.camera);
}

// Start!
init();


    </script>
</body>
</html>



